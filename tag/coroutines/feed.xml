<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator>
  <link href="https://manuelvivo.dev/tag/coroutines/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://manuelvivo.dev/" rel="alternate" type="text/html" />
  <updated>2025-07-07T10:14:22+00:00</updated>
  <id>https://manuelvivo.dev/tag/coroutines/feed.xml</id>

  
  
  

  
    <title type="html">Manuel Vivo .dev | </title>
  

  
    <subtitle>A place where you can learn about Android development</subtitle>
  

  

  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
  

  
    <entry>
      <title type="html">Kotlin Flows in practice</title>
      <link href="https://manuelvivo.dev/kotlin-flows-in-practice" rel="alternate" type="text/html" title="Kotlin Flows in practice" />
      <published>2021-10-27T00:00:00+00:00</published>
      <updated>2021-10-27T00:00:00+00:00</updated>
      <id>https://manuelvivo.dev/kotlin-flows-in-practice</id>
      <content type="html" xml:base="https://manuelvivo.dev/kotlin-flows-in-practice">&lt;p&gt;Kotlin Flows in practice — Android Dev Summit 2021 talk&lt;/p&gt;

&lt;h2 id=&quot;description&quot;&gt;Description&lt;/h2&gt;

&lt;p&gt;With coroutines as the recommended solution for asynchronous operations, Kotlin Flow is the obvious choice for managing streams of data in Android apps. However, there are some lifecycle perils to consider and new lifecycle-aware APIs to understand in order to get the most out of Flows in Android. Learn about the powerful and expressive Flow APIs and how to use them across all layers of your app in a practical way—solving common use cases every developer can face.&lt;/p&gt;

&lt;p&gt;Speakers: Manuel Vicente Vivo, Jose Alcérreca&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/fSB6_KE95bU&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h3 id=&quot;resources&quot;&gt;Resources&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.android.com/kotlin/flow&quot;&gt;Kotlin Flows documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Manuel Vivo</name>
        
        
      </author>

      

      
        <category term="talks" />
      
        <category term="coroutines" />
      

      
        <summary type="html">Kotlin Flows in practice — Android Dev Summit 2021 talk</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">repeatOnLifecycle API design story</title>
      <link href="https://manuelvivo.dev/repeatonlifecycle" rel="alternate" type="text/html" title="repeatOnLifecycle API design story" />
      <published>2021-07-01T00:00:00+00:00</published>
      <updated>2021-07-01T00:00:00+00:00</updated>
      <id>https://manuelvivo.dev/repeatonlifecycle</id>
      <content type="html" xml:base="https://manuelvivo.dev/repeatonlifecycle">&lt;p&gt;Learn the design decisions behind the Lifecycle.repeatOnLifecycle API.&lt;/p&gt;

&lt;p&gt;In this blog post, you’ll learn the design decisions behind the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lifecycle.repeatOnLifecycle&lt;/code&gt; API and why we removed some of the helper functions we added in the first alpha version of the 2.4.0 &lt;a href=&quot;https://developer.android.com/jetpack/androidx/releases/lifecycle&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lifecycle-runtime-ktx&lt;/code&gt;&lt;/a&gt; library.&lt;/p&gt;

&lt;p&gt;Along the way, you’ll see how certain coroutines APIs can be dangerous to use in some scenarios, how difficult naming is, and why we decided to keep only the low-level suspend APIs in the library.&lt;/p&gt;

&lt;p&gt;Also, you’ll realize all API decisions require some tradeoffs regarding complexity, readability, and how error prone the API is.&lt;/p&gt;

&lt;p&gt;Special shout-out to &lt;a href=&quot;https://twitter.com/adamwp&quot;&gt;Adam Powell&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/wkalic&quot;&gt;Wojtek Kaliciński&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/ianhlake&quot;&gt;Ian Lake&lt;/a&gt;, and &lt;a href=&quot;https://twitter.com/yigitboyar&quot;&gt;Yigit Boyar&lt;/a&gt; for giving feedback and discussing the shape of these APIs.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: If you’re looking for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; guidance, check out the &lt;a href=&quot;https://manuelvivo.dev/coroutines-addrepeatingjob&quot;&gt;A safer way to collect flows from Android UIs blog post&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;repeatonlifecycle&quot;&gt;repeatOnLifecycle&lt;/h2&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lifecycle.repeatOnLifecycle&lt;/code&gt; API was primarily born to allow safer Flow collection from the UI layer in Android. Its restartable behavior, that takes into consideration the UI lifecycle, makes it the perfect default API to process items only when the UI is visible on the screen.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LifecycleOwner.repeatOnLifecycle&lt;/code&gt; is also available. It delegates the functionality to its Lifecycle. With this, any code that’s already part of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LifecycleOwner&lt;/code&gt; scope can omit the explicit receiver.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; is a suspend function&lt;/strong&gt;. As such, it needs to be executed within a coroutine. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; suspends the calling coroutine, and then runs a given suspend &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;block&lt;/code&gt; that you pass as a parameter in a new coroutine each time the given lifecycle reaches a target state or higher. If the lifecycle state falls below the target, the coroutine launched for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;block&lt;/code&gt; is cancelled. Lastly, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; function itself won’t resume the calling coroutine until the lifecycle is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DESTROYED&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let’s see this API in action. If you read my previous &lt;a href=&quot;https://manuelvivo.dev/coroutines-addrepeatingjob&quot;&gt;A safer way to collect flows from Android UIs blog post&lt;/a&gt;, none of this should come as a surprise to you.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Create a new coroutine from the lifecycleScope&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// since repeatOnLifecycle is a suspend function&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;lifecycleScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Suspend the coroutine until the lifecycle is DESTROYED.&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// repeatOnLifecycle launches the block in a new coroutine every time the &lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// lifecycle is in the STARTED state (or above) and cancels it when it's STOPPED.&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;repeatOnLifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;STARTED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// Safely collect from locations when the lifecycle is STARTED&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// and stop collecting when the lifecycle is STOPPED&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;someLocationProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;collect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// New location! Update the map&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Note: at this point, the lifecycle is DESTROYED!&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: if you’re interested in how &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; is implemented, here’s a &lt;a href=&quot;https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:lifecycle/lifecycle-runtime-ktx/src/main/java/androidx/lifecycle/RepeatOnLifecycle.kt;l=63&quot;&gt;link to its source code&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;why-its-a-suspend-function&quot;&gt;Why it’s a suspend function&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;A suspend function is the best choice&lt;/strong&gt; for this restarting behavior as it preserves the calling context. It &lt;em&gt;respects&lt;/em&gt; the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Job&lt;/code&gt; tree of the calling coroutine. As &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt;’s implementation uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;suspendCancellableCoroutine&lt;/code&gt; under the hood, it cooperates with cancellation: cancelling the calling coroutine also cancels &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; and its restarting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;block&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Also, we can add more APIs on top of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; such as the &lt;a href=&quot;https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:lifecycle/lifecycle-runtime-ktx/src/main/java/androidx/lifecycle/FlowExt.kt;l=87&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow.flowWithLifecycle&lt;/code&gt;&lt;/a&gt; flow operator. More importantly, it also allows you to create helper functions on top of this API if that’s what your project needs. That’s what we tried to do with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LifecycleOwner.addRepeatingJob&lt;/code&gt; API that we added in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lifecycle-runtime-ktx:2.4.0-alpha01&lt;/code&gt; and, in fact, removed in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alpha02&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;removing-the-addrepeatingjob-api&quot;&gt;Removing the addRepeatingJob API&lt;/h2&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LifecycleOwner.addRepeatingJob&lt;/code&gt; API added in the first alpha version of the library with this functionality, and now removed from the library, was implemented like this:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LifecycleOwner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;addRepeatingJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;coroutineContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineContext&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EmptyCoroutineContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Unit&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Job&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lifecycleScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutineContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;repeatOnLifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Given a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LifecycleOwner&lt;/code&gt;, you could run a suspend block that restarts whenever its lifecycle moves in and out of the target state. This API uses the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LifecycleOwner&lt;/code&gt;’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lifecycleScope&lt;/code&gt; to trigger a new coroutine and call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; inside it.&lt;/p&gt;

&lt;p&gt;The code above would look like this using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addRepeatingJob&lt;/code&gt; API:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;lifecycleOwner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;addRepeatingJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;STARTED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;someLocationProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;collect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// New location! Update the map&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;At first glance, you might think that this code is cleaner and requires less code. However, there are hidden gotchas that can make you shoot yourself in the foot if you don’t pay close attention:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Even though &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addRepeatingJob&lt;/code&gt; takes a suspend block, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addRepeatingJob&lt;/code&gt; is &lt;strong&gt;NOT&lt;/strong&gt; a suspend function. Thus, you shouldn’t call it inside a coroutine!!!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Less code? You only save one line of code with the cost of having a more error-prone API.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first point might seem obvious but it always bites developers. And ironically, it’s actually based on one of the most conceptually core concepts of coroutines: &lt;a href=&quot;https://elizarov.medium.com/structured-concurrency-722d765aa952&quot;&gt;&lt;strong&gt;Structured Concurrency&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addRepeatingJob&lt;/code&gt; is not a suspend function, and therefore, doesn’t support structured concurrency by default (note that you could manually make it support it by using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;coroutineContext&lt;/code&gt; that it takes as a parameter). Since the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;block&lt;/code&gt; parameter is a suspend lambda, you relate this API to coroutines and you could easily write dangerous code like this:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;job&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lifecycleScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

            &lt;span class=&quot;nf&quot;&gt;doSomeSuspendInitWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// DANGEROUS! This API doesn't preserve the calling Context!&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// It won't get cancelled when the parent coroutine is cancelled!&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;addRepeatingJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;STARTED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;someLocationProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;collect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// New location! Update the map&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// If something goes wrong, cancel the coroutine launched above&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What’s wrong with this code? &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addRepeatingJob&lt;/code&gt; does coroutines stuff, nothing prevents me from calling it inside a coroutine, right?&lt;/p&gt;

&lt;p&gt;As &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addRepeatingJob&lt;/code&gt; creates new coroutines to run the repeating block using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lifecycleScope&lt;/code&gt; which is implicit in the implementation details, the new coroutines don’t respect structured concurrency nor preserve the calling coroutine context. Therefore, will NOT get canceled when you call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;job.cancel()&lt;/code&gt;. &lt;strong&gt;This can lead to very subtle bugs in your app which are really difficult to debug&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;repeatonlifecycle-ftw&quot;&gt;repeatOnLifecycle FTW&lt;/h2&gt;

&lt;p&gt;The implicit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt; used inside &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addRepeatingJob&lt;/code&gt; is what makes the API unsafe to use in certain situations. It’s the hidden gotcha that requires extra attention to write correct code. This point is the recurring argument to avoid additional wrapper APIs on top of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; in the library.&lt;/p&gt;

&lt;p&gt;The main benefit of the suspend &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; API is that it cooperates with structured concurrency by default, whereas &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addRepeatingJob&lt;/code&gt; did not. It also helps you think in which scope you want the repeating job to happen. The API is self-explanatory and meets developer expectations:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;As any other suspend function, it will suspend the execution of the coroutine until something happens. In this case, until the lifecycle is destroyed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;No surprises! It can be used in conjunction with other coroutines code and it’ll behave as you expect.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The code surrounding &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; is readable and makes sense for newcomers: &lt;em&gt;“First, I launch a new coroutine that follows the UI lifecycle. Then, I call repeatOnLifecycle that launches this block every time the UI reaches this lifecycle state”&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;flowflowwithlifecycle&quot;&gt;Flow.flowWithLifecycle&lt;/h2&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow.flowWithLifecycle&lt;/code&gt; operator (&lt;a href=&quot;https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:lifecycle/lifecycle-runtime-ktx/src/main/java/androidx/lifecycle/FlowExt.kt;l=87&quot;&gt;implementation here&lt;/a&gt;) is built on top of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; and only emits items sent by the upstream flow whenever the lifecycle is at least at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;minActiveState&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;lifecycleScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;someLocationProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locations&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;flowWithLifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;STARTED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;collect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// New location! Update the map&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Even though this API also comes with some gotchas to be aware of, we decided to keep it in as it’s useful as a Flow operator. For example, it can be &lt;a href=&quot;https://manuelvivo.dev/coroutines-addrepeatingjob#safe-flow-collection-in-jetpack-compose&quot;&gt;easily used in Jetpack Compose&lt;/a&gt;. Even though you could achieve the same functionality in Compose by using the &lt;a href=&quot;https://developer.android.com/jetpack/compose/side-effects#producestate&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;produceState&lt;/code&gt;&lt;/a&gt; and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; API, we left this API in the library as an alternative to a more reactive approach.&lt;/p&gt;

&lt;p&gt;The gotcha, as it’s documented in the KDoc, is that the order in which you add the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flowWithLifecycle&lt;/code&gt; operator matters. Operators applied before the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flowWithLifecycle&lt;/code&gt; operator will be cancelled when the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lifecycle&lt;/code&gt; is below &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;minActiveState&lt;/code&gt;. However, operators applied &lt;em&gt;after&lt;/em&gt; won’t be cancelled even though no items are sent.&lt;/p&gt;

&lt;p&gt;For the most curious ones, this API name takes the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow.flowOn(CoroutineContext)&lt;/code&gt; operator as a precedent since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow.flowWithLifecycle&lt;/code&gt; changes the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineContext&lt;/code&gt; used to collect the upstream flow while leaving the downstream unaffected.&lt;/p&gt;

&lt;h2 id=&quot;should-we-add-an-additional-api&quot;&gt;Should we add an additional API?&lt;/h2&gt;

&lt;p&gt;Given that we already have the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lifecycle.repeatOnLifecycle&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LifecycleOwner.repeatOnLifecycle&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow.flowWithLifecycle&lt;/code&gt; APIs. Should we add any other API?&lt;/p&gt;

&lt;p&gt;New APIs can introduce as much confusion as problems they’d solve. There are multiple ways to support different use cases, and the shortest path depends greatly on the surrounding code. What might work for your project, might not work for others.&lt;/p&gt;

&lt;p&gt;This is why we don’t want to provide APIs for all the possible cases, the more APIs available, the more confusing it will be for developers to know &lt;em&gt;what&lt;/em&gt; to use &lt;em&gt;when&lt;/em&gt;. Therefore, we made the decision of just keeping the most low-level APIs. Sometimes, less is more.&lt;/p&gt;

&lt;h2 id=&quot;naming-is-important-and-difficult&quot;&gt;Naming is important (and difficult)&lt;/h2&gt;

&lt;p&gt;It’s not only about which use cases we support, but also, how to name them! Names should comply with developers’ expectations and follow the Kotlin coroutines conventions. For example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;If the API starts a new coroutine using an implicit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt; (for example the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lifecycleScope&lt;/code&gt; used implicitly in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addRepeatingJob&lt;/code&gt;), this must be reflected in the name to avoid false expectations! In this case, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;launch&lt;/code&gt; should be somehow included in the name.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;collect&lt;/code&gt; is a suspend function. Don’t prefix an API name with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;collect&lt;/code&gt; if it’s not a suspend function.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: Compose’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;collectAsState&lt;/code&gt; API is a special case whose name we’re ok with. It cannot be confused for a suspend function since there’s no such thing as a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Composable suspend fun&lt;/code&gt; in Compose.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Even the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LifecycleOwner.addRepeatingJob&lt;/code&gt; API was a tough one to name. As it creates new coroutines with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lifecycleScope&lt;/code&gt;, it should’ve been prefixed with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;launch&lt;/code&gt;. However, we wanted to disassociate the fact that coroutines were used under the hood, and since it adds a new lifecycle observer, the name was more consistent with the rest of other LifecycleOwner APIs.&lt;/p&gt;

&lt;p&gt;The name was also somewhat influenced by the existing &lt;a href=&quot;https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleCoroutineScope&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LifecycleCoroutineScope.launchWhenX&lt;/code&gt;&lt;/a&gt; suspending APIs. As &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;launchWhenStarted&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle(STARTED)&lt;/code&gt; provide completely different functionality (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;launchWhenStarted&lt;/code&gt; suspends the execution of the coroutine, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; cancels and restarts a new coroutine), if the names of the new APIs were similar (for example, using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;launchWhenever&lt;/code&gt; for the restarting APIs), developers could’ve got confused and even use them interchangeably without noticing.&lt;/p&gt;

&lt;h2 id=&quot;one-liner-flow-collection&quot;&gt;One-liner flow collection&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt;’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;observe&lt;/code&gt; function is lifecycle aware and only processes emissions when the lifecycle is at least started. If you’re migrating from LiveData to Kotlin flows, you might think that having a one-line replacement is a good idea! You could remove boilerplate code and the migration is straightforward.&lt;/p&gt;

&lt;p&gt;As such, you can do as &lt;a href=&quot;https://twitter.com/ianhlake&quot;&gt;Ian Lake&lt;/a&gt; did when he first started playing around with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; APIs. He created a convenience wrapper called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;collectIn&lt;/code&gt; like the following (to follow the naming conventions discussed above, I’m renaming it to be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;launchAndCollectIn&lt;/code&gt;):&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launchAndCollectIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;owner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LifecycleOwner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;minActiveState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;STARTED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;crossinline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Unit&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;owner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lifecycleScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;owner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;repeatOnLifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;minActiveState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;collect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So that you could call it from the UI like this:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;someLocationProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launchAndCollectIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;STARTED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// New location! Update the map&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This wrapper, as nice and straightforward it might look in this example, suffers from the same problems we mentioned earlier regarding &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LifecycleOwner.addRepeatingJob&lt;/code&gt;. It doesn’t respect the calling context and can be dangerous to use inside other coroutines. Furthermore, the original name is really misleading: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;collectIn&lt;/code&gt; is not a suspend function! As mentioned before, developers expect &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;collect&lt;/code&gt; functions to suspend. Maybe, a better name for this wrapper could be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow.launchAndCollectIn&lt;/code&gt; to prevent bad usages.&lt;/p&gt;

&lt;h2 id=&quot;wrapper-in-iosched&quot;&gt;Wrapper in iosched&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; must be used with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;viewLifecycleOwner&lt;/code&gt; in Fragments. In the open source Google I/O app, the &lt;a href=&quot;https://github.com/google/iosched&quot;&gt;iosched&lt;/a&gt; project, the team decided to create a wrapper to avoid misusages of the API in Fragments with a very explicit API name: &lt;a href=&quot;https://github.com/google/iosched/blob/main/mobile/src/main/java/com/google/samples/apps/iosched/util/UiUtils.kt#L60&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fragment.launchAndRepeatWithViewLifecycle&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: The implementation is very similar to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addRepeatingJob&lt;/code&gt; API. And when this was written using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alpha01&lt;/code&gt; version of the library, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; API lint checks that were added in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alpha02&lt;/code&gt; were not in place.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;do-you-need-a-wrapper&quot;&gt;Do you need a wrapper?&lt;/h2&gt;

&lt;p&gt;If you need to create wrappers on top of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; API to accommodate the most common use cases you might have in your app, ask yourself if you really need it, and why you need it. If you’re convinced and want to go forward, I’d suggest you choose a very explicit API name to clearly define what’s the wrapper’s behavior to avoid misusages. Also, document it very clearly so that newcomers can fully understand the implications of using it.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;I hope this blog post gave you an idea of what considerations the team had when deciding what to do with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; APIs and the potential helper methods we could add on top of it.&lt;/p&gt;

&lt;p&gt;Again, thanks to &lt;a href=&quot;https://twitter.com/adamwp&quot;&gt;Adam Powell&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/wkalic&quot;&gt;Wojtek Kaliciński&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/ianhlake&quot;&gt;Ian Lake&lt;/a&gt;, and &lt;a href=&quot;https://twitter.com/yigitboyar&quot;&gt;Yigit Boyar&lt;/a&gt; for giving feedback and discussing the shape of these APIs.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Manuel Vivo</name>
        
        
      </author>

      

      
        <category term="coroutines" />
      

      
        <summary type="html">Learn the design decisions behind the Lifecycle.repeatOnLifecycle API.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Create an application CoroutineScope using Hilt</title>
      <link href="https://manuelvivo.dev/coroutinescope-hilt" rel="alternate" type="text/html" title="Create an application CoroutineScope using Hilt" />
      <published>2021-06-10T00:00:00+00:00</published>
      <updated>2021-06-10T00:00:00+00:00</updated>
      <id>https://manuelvivo.dev/coroutinescope-hilt</id>
      <content type="html" xml:base="https://manuelvivo.dev/coroutinescope-hilt">&lt;p&gt;Inject an application-scoped &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt; using Hilt.&lt;/p&gt;

&lt;p&gt;Following &lt;a href=&quot;https://developer.android.com/kotlin/coroutines/coroutines-best-practices&quot;&gt;coroutine’s best practices&lt;/a&gt;, you might need to inject an application-scoped &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt; in some classes to &lt;a href=&quot;https://developer.android.com/kotlin/coroutines/coroutines-best-practices#create-coroutines-data-layer&quot;&gt;launch new coroutines that follow the app lifecycle or to make certain work outlive the caller’s scope&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this article, you’ll learn how to create an application-scoped &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt; using Hilt, and how to inject it as a dependency. To further improve the way we work with Coroutines, we’ll see how to inject the different &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt;s and replace their implementations in tests.&lt;/p&gt;

&lt;h2 id=&quot;manual-dependency-injection&quot;&gt;Manual dependency injection&lt;/h2&gt;

&lt;p&gt;To create an &lt;a href=&quot;https://medium.com/androiddevelopers/scoping-in-android-and-hilt-c2e5222317c0&quot;&gt;application-scoped&lt;/a&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt; following dependency injection (DI) best practices &lt;a href=&quot;https://developer.android.com/training/dependency-injection/manual&quot;&gt;manually&lt;/a&gt; without any library, you’d typically add a new variable to your application class with an instance of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt;. The same instance would be manually passed around when creating other objects.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyApplication&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Application&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Application-scoped types that any class in the app could access&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// using the applicationContext.&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;applicationScope&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SupervisorJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;myRepository&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;applicationScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Since there isn’t a reliable way to know when the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Application&lt;/code&gt; is destroyed in Android, you don’t need to call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;applicationScope.cancel()&lt;/code&gt; manually as the scope and all ongoing work will be destroyed when the application process finishes.&lt;/p&gt;

&lt;p&gt;A better option for doing this manually is to create an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationContainer&lt;/code&gt; class that holds the application-scoped types. This helps with separation of concerns since these &lt;em&gt;Container&lt;/em&gt; classes are responsible for:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;handling the logic of &lt;em&gt;how&lt;/em&gt; to build certain types,&lt;/li&gt;
  &lt;li&gt;holding container-scoped types instances, and&lt;/li&gt;
  &lt;li&gt;returning instances of scoped and unscoped types.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ApplicationDiContainer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;applicationScope&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SupervisorJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;myRepository&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;applicationScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyApplication&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Application&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;applicationDiContainer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ApplicationDiContainer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: A container always returns the same instance of a scoped type, and always returns a different instance for unscoped types. Scoping types to containers is &lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-android#component-scopes&quot;&gt;costly&lt;/a&gt; since the scoped object stays in memory until the component is destroyed, so only scope what’s really needed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationDiContainer&lt;/code&gt; example above, all types were scoped. If &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MyRepository&lt;/code&gt; didn’t need to be scoped to the application, we’d have:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ApplicationDiContainer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Scoped type. Same instance is always returned&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;applicationScope&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SupervisorJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Unscoped type. Always returns a different instance&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getMyRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyRepository&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;applicationScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;using-hilt-in-your-app&quot;&gt;Using Hilt in your app&lt;/h2&gt;

&lt;p&gt;Hilt generates what you can see in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ApplicationDiContainer&lt;/code&gt; (and more!) at compile time using annotations. Moreover, Hilt provides containers for &lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-android#generated-components&quot;&gt;most Android framework classes&lt;/a&gt; not only for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Application&lt;/code&gt; class.&lt;/p&gt;

&lt;p&gt;To set up Hilt in your app and create the container for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Application&lt;/code&gt; class, annotate your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Application&lt;/code&gt; class with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@HiltAndroidApp&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@HiltAndroidApp&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyApplication&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Application&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With this, the application DI container is ready to be used. We just need to let Hilt know how to provide instances of different types.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: In Hilt, Container classes are referenced as Components. The container associated with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Application&lt;/code&gt; class is called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SingletonComponent&lt;/code&gt;. Check out the &lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-android#generated-components&quot;&gt;list of all available Hilt components&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;construction-injection&quot;&gt;Construction injection&lt;/h2&gt;

&lt;p&gt;Construction injection is the easiest way to let Hilt know how to provide instances of a type if we have access to the constructor of a class as we only need to annotate the constructor with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Inject&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Singleton&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Scopes this type to the SingletonComponent&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyRepository&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Inject&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This lets Hilt know that in order to provide an instance of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MyRepository&lt;/code&gt; class, an instance of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt; needs to be passed as a dependency. Hilt generates code at compile time to make sure dependencies are satisfied and passed in when creating an instance of a type or give errors in case it doesn’t have enough information. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Singleton&lt;/code&gt; is used to scope this class to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SingletonContainer&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;At this point, Hilt doesn’t know how to satisfy the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt; dependency because we haven’t told Hilt how to do that. The following sections will explain how we can let Hilt know what to pass as a dependency.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: Hilt provides a different annotation to scope types to the different Hilt available components. Check out the &lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-android#component-scopes&quot;&gt;list of all available component scopes&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;bindings&quot;&gt;Bindings&lt;/h2&gt;

&lt;p&gt;A &lt;em&gt;binding&lt;/em&gt; is a commonly-used term in Hilt that denotes the &lt;strong&gt;information&lt;/strong&gt; Hilt knows about how to provide instances of a type as a dependency. We could say that we added a binding to Hilt with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Inject&lt;/code&gt; annotation of the code snippet above.&lt;/p&gt;

&lt;p&gt;Bindings flow through &lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-android#component-hierarchy&quot;&gt;Hilt’s components hierarchy&lt;/a&gt;. Bindings that are available in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SingletonComponent&lt;/code&gt; are also available in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ActivityComponent&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Bindings for unscoped types (an example of this could’ve been the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MyRepository&lt;/code&gt; code above if it wasn’t annotated with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Singleton&lt;/code&gt;), are available in all Hilt components. Bindings that are scoped to a component, such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MyRepository&lt;/code&gt; that is annotated with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Singleton&lt;/code&gt;, are available to the scoped component and the components below it in the hierarchy.&lt;/p&gt;

&lt;h2 id=&quot;providing-types-with-modules&quot;&gt;Providing types with modules&lt;/h2&gt;

&lt;p&gt;As mentioned above, we need to let Hilt know how to satisfy the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt; dependency. However, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt; is an interface type that comes from an external library, so we cannot use constructor injection as we did before with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MyRepository&lt;/code&gt; class. The alternative is letting Hilt know what code to run when providing the instance of a type &lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-android#hilt-modules&quot;&gt;using Modules&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@InstallIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SingletonComponent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Module&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutinesScopesModule&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Singleton&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Provide always the same instance &lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Provides&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;providesCoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Run this code when providing an instance of CoroutineScope&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SupervisorJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-android#inject-provides&quot;&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Provides&lt;/code&gt; method&lt;/a&gt; is annotated with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Singleton&lt;/code&gt; to make Hilt always return the same instance of that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt;. This is because any work that needs to follow the application lifetime should be created using the same instance of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt; that follows the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Application&lt;/code&gt;’s lifecycle.&lt;/p&gt;

&lt;p&gt;Hilt modules are annotated with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@InstallIn&lt;/code&gt; that indicates in which Hilt component (and components below in the hierarchy) the binding is installed. In our case, as the application &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt; is needed by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MyRepository&lt;/code&gt; which is scoped to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SingletonComponent&lt;/code&gt;, this binding needs to be installed in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SingletonComponent&lt;/code&gt; as well.&lt;/p&gt;

&lt;p&gt;In Hilt jargon, we could say that we added a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt; binding, as now, Hilt knows how to provide instances of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;However, the code snippet above could be improved. &lt;a href=&quot;https://developer.android.com/kotlin/coroutines/coroutines-best-practices#inject-dispatchers&quot;&gt;Hardcoding dispatchers is a bad practice in coroutines&lt;/a&gt;, we should inject them to &lt;strong&gt;make them configurable and make testing easier&lt;/strong&gt;. Following the previous code, we can create a new Hilt module to let it know which Dispatcher to inject for each case: main, default, and IO.&lt;/p&gt;

&lt;h2 id=&quot;providing-implementations-for-coroutinedispatcher&quot;&gt;Providing implementations for CoroutineDispatcher&lt;/h2&gt;

&lt;p&gt;We have to provide different implementations for the same type: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt;. In other words, we need different bindings for the same type.&lt;/p&gt;

&lt;p&gt;We use &lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-android#multiple-bindings&quot;&gt;&lt;em&gt;qualifiers&lt;/em&gt;&lt;/a&gt; to let Hilt know which binding, or implementation, to use each time. Qualifiers are just annotations that you and Hilt use to identify specific bindings. Let’s create one qualifier per &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt; implementation:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// CoroutinesQualifiers.kt file&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@Retention&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AnnotationRetention&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;RUNTIME&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Qualifier&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;annotation&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DefaultDispatcher&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@Retention&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AnnotationRetention&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;RUNTIME&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Qualifier&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;annotation&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IoDispatcher&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@Retention&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AnnotationRetention&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;RUNTIME&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Qualifier&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;annotation&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MainDispatcher&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@Retention&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AnnotationRetention&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;BINARY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Qualifier&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;annotation&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MainImmediateDispatcher&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then, these qualifiers annotate the different &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Provides&lt;/code&gt; methods to identify a specific binding in Hilt modules. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@DefaultDispatcher&lt;/code&gt; qualifier annotates the method that returns the default dispatcher, and so on.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@InstallIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SingletonComponent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Module&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutinesDispatchersModule&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@DefaultDispatcher&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Provides&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;providesDefaultDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineDispatcher&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Default&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@IoDispatcher&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Provides&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;providesIoDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineDispatcher&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;IO&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@MainDispatcher&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Provides&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;providesMainDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineDispatcher&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Main&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@MainImmediateDispatcher&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Provides&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;providesMainImmediateDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineDispatcher&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;immediate&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note that these &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt;s don’t need to be scoped to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SingletonComponent&lt;/code&gt;. Every time these dependencies are needed, Hilt calls the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Provides&lt;/code&gt; method and returns the corresponding &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;providing-an-application-scoped-coroutinescope&quot;&gt;Providing an application-scoped CoroutineScope&lt;/h2&gt;

&lt;p&gt;To get rid of the hardcoded &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt; from our previous application-scoped &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt; code, we need to inject the Hilt-provided default dispatcher. For that, we can pass in the type we want to inject, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt;, using the corresponding qualifier, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@DefaultDispatcher&lt;/code&gt;, as a dependency in the method that provides the application &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@InstallIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SingletonComponent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Module&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutinesScopesModule&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Singleton&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Provides&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;providesCoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;nd&quot;&gt;@DefaultDispatcher&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defaultDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineDispatcher&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SupervisorJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defaultDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As Hilt has multiple bindings for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt; type, we disambiguate it using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@DefaultDispatcher&lt;/code&gt; annotation when &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt; is used as a dependency.&lt;/p&gt;

&lt;h2 id=&quot;a-qualifier-for-applicationscope&quot;&gt;A qualifier for ApplicationScope&lt;/h2&gt;

&lt;p&gt;Even though we don’t need multiple bindings for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt; at the moment (this could change in the future if we ever need something like a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UserCoroutineScope&lt;/code&gt;), adding a qualifier to the application &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt; helps with readability when injecting it as a dependency.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Retention&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AnnotationRetention&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;RUNTIME&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Qualifier&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;annotation&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ApplicationScope&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@InstallIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SingletonComponent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Module&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutinesScopesModule&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Singleton&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@ApplicationScope&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Provides&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;providesCoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;nd&quot;&gt;@DefaultDispatcher&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defaultDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineDispatcher&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SupervisorJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defaultDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MyRepository&lt;/code&gt; depends on this scope, it’s very clear which external scope uses as implementation:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Singleton&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyRepository&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Inject&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@ApplicationScope&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;replacing-dispatchers-for-instrumentation-tests&quot;&gt;Replacing Dispatchers for instrumentation tests&lt;/h2&gt;

&lt;p&gt;We said before that we should inject dispatchers to make testing easier and have full control over what’s happening. For instrumentation tests, we’d want to make Espresso wait for coroutines to finish.&lt;/p&gt;

&lt;p&gt;Instead of creating a custom &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt; with some &lt;a href=&quot;https://developer.android.com/training/testing/espresso/idling-resource&quot;&gt;Espresso Idling resource&lt;/a&gt; to make it wait for the coroutines to finish, we can take advantage of the &lt;a href=&quot;https://developer.android.com/reference/android/os/AsyncTask&quot;&gt;AsyncTask&lt;/a&gt; API. Even though AsyncTask was deprecated in Android API 30, Espresso hooks into its thread pool to check for idleness. Therefore, any coroutine that should be executed in a background thread could be executed in the AsyncTask’s thread pool.&lt;/p&gt;

&lt;p&gt;Use Hilt’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TestInstallIn&lt;/code&gt; API to make Hilt provide a different implementation of a type in tests. Similar to how we provided the different Dispatchers above, we can create a new file under the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;androidTest&lt;/code&gt; package to provide different implementations for those Dispatchers.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// androidTest/projectPath/TestCoroutinesDispatchersModule.kt file&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@TestInstallIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;components&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SingletonComponent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;replaces&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;CoroutinesDispatchersModule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Module&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestCoroutinesDispatchersModule&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@DefaultDispatcher&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Provides&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;providesDefaultDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineDispatcher&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;AsyncTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;THREAD_POOL_EXECUTOR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;asCoroutineDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@IoDispatcher&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Provides&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;providesIoDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineDispatcher&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;AsyncTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;THREAD_POOL_EXECUTOR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;asCoroutineDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@MainDispatcher&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Provides&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;providesMainDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineDispatcher&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Main&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With the code above, we’re making Hilt “forget” the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutinesDispatchersModule&lt;/code&gt; used in production code in tests. That module will be replaced with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TestCoroutinesDispatchersModule&lt;/code&gt; which uses the Async Task’s thread pool for work that needs to happen in the background, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dispatchers.Main&lt;/code&gt; for work that needs to happen on the main thread which Espresso also waits for.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Warning: This implementation is obviously a hack that we’re not proud of. However, coroutines don’t currently integrate well with Espresso as there isn’t a way to know if a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt; is idle or not at the moment (&lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/issues/242&quot;&gt;Link to bug&lt;/a&gt;). &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AsyncTask.THREAD_POOL_EXECUTOR&lt;/code&gt; is the best alternative to use at the moment since Espresso doesn’t use Idling resources to check if this executor is idle, Espresso uses a different heuristic that takes into account what’s in the message queue. That makes it a better option than something like &lt;a href=&quot;https://developer.android.com/reference/androidx/test/espresso/idling/concurrent/IdlingThreadPoolExecutor&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IdlingThreadPoolExecutor&lt;/code&gt;&lt;/a&gt; which unfortunately considers the thread pool idle when a coroutine is suspended due to how coroutines are compiled down to a state machine.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For more information about testing, check out &lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-testing&quot;&gt;Hilt’s testing guide&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;In this article, you learnt how to create an application-scoped &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt; using Hilt, inject it as a dependency, inject the different &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt; instances, and replace their implementations in tests.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Manuel Vivo</name>
        
        
      </author>

      

      
        <category term="coroutines" />
      
        <category term="hilt" />
      

      
        <summary type="html">Inject an application-scoped CoroutineScope using Hilt.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Things to know about Flow’s shareIn and stateIn operators</title>
      <link href="https://manuelvivo.dev/sharein-statein" rel="alternate" type="text/html" title="Things to know about Flow’s shareIn and stateIn operators" />
      <published>2021-05-07T00:00:00+00:00</published>
      <updated>2021-05-07T00:00:00+00:00</updated>
      <id>https://manuelvivo.dev/sharein-statein</id>
      <content type="html" xml:base="https://manuelvivo.dev/sharein-statein">&lt;p&gt;Become familiar with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shareIn&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateIn&lt;/code&gt; operators by example.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/share-in.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow.shareIn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/state-in.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow.stateIn&lt;/code&gt;&lt;/a&gt; operators convert cold flows into hot flows: they can multicast the information that comes from a cold upstream flow to multiple collectors. They’re often used to improve performance, add a buffer when collectors are not present, or even as a caching mechanism.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Cold flows&lt;/strong&gt; are created on-demand and emit data when they’re being observed. &lt;strong&gt;Hot flows&lt;/strong&gt; are always active and can emit data regardless of whether or not they’re being observed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In this blog post, you’ll become familiar with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shareIn&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateIn&lt;/code&gt; operators by example. You’ll learn how to configure them to perform certain use cases and avoid common pitfalls you might encounter.&lt;/p&gt;

&lt;h2 id=&quot;the-underlying-flow-producer&quot;&gt;The underlying flow producer&lt;/h2&gt;

&lt;p&gt;Continuing with the example from my &lt;a href=&quot;https://manuelvivo.dev/coroutines-addrepeatingjob&quot;&gt;previous blog post&lt;/a&gt;, the underlying flow producer that we’re using emits location updates. It’s a &lt;em&gt;cold&lt;/em&gt; flow, as it’s implemented using a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/callback-flow.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt;&lt;/a&gt;. Every new collector will trigger the flow producer block, and a new callback will be added to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FusedLocationProviderClient&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;locationClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FusedLocationProviderClient&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;locationsSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callbackFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;callback&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;: &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LocationCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onLocationResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;offer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lastLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;requestLocationUpdates&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;createLocationRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Looper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getMainLooper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;addOnFailureListener&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// in case of exception, close the Flow&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// clean up when Flow collection ends&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;awaitClose&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;removeLocationUpdates&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Let’s see how we can use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shareIn&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateIn&lt;/code&gt; operators to optimize the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;locationsSource&lt;/code&gt; flow for different use cases.&lt;/p&gt;

&lt;h2 id=&quot;sharein-or-statein&quot;&gt;shareIn or stateIn?&lt;/h2&gt;

&lt;p&gt;The first topic we’ll cover is the difference between &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shareIn&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateIn&lt;/code&gt;. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shareIn&lt;/code&gt; operator returns a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SharedFlow&lt;/code&gt;&lt;/a&gt; instance whereas &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateIn&lt;/code&gt; returns a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/index.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateFlow&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: To learn more about &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateFlow&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SharedFlow&lt;/code&gt;, check out &lt;a href=&quot;https://developer.android.com/kotlin/flow/stateflow-and-sharedflow&quot;&gt;our documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateFlow&lt;/code&gt; is a specialized configuration of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SharedFlow&lt;/code&gt; optimized for sharing state: the last emitted item is replayed to new collectors, and items are conflated using &lt;a href=&quot;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/equals.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Any.equals&lt;/code&gt;&lt;/a&gt;. You can read more about this in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/index.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateFlow&lt;/code&gt; documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The main difference between these APIs is that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateFlow&lt;/code&gt; interface allows you to access the last emitted value synchronously by reading its &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;value&lt;/code&gt; property. That’s not the case with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SharedFlow&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;improving-performance&quot;&gt;Improving performance&lt;/h2&gt;

&lt;p&gt;These APIs can improve performance by sharing the same instance of the flow to be observed by all collectors instead of creating new instances of the same flow on-demand.&lt;/p&gt;

&lt;p&gt;In the following example, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LocationRepository&lt;/code&gt; consumes the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;locationsSource&lt;/code&gt; flow exposed by the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LocationDataSource&lt;/code&gt; and applies the shareIn operator to make everyone interested in the user’s location collect from the same instance of the flow. Only one instance of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;locationsSource&lt;/code&gt; flow is created and shared for all collectors:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;locationDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;locations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;locationDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locationsSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;shareIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WhileSubscribed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/-while-subscribed.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WhileSubscribed&lt;/code&gt;&lt;/a&gt; sharing policy is used to cancel the upstream flow when there are no collectors. In this way, we avoid wasting resources when no one is interested in location updates.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Tip for Android apps!&lt;/strong&gt; You can use &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WhileSubscribed(5000)&lt;/code&gt;&lt;/strong&gt; most of the time to keep the upstream flow active for 5 seconds more after the disappearance of the last collector. That avoids restarting the upstream flow in certain situations such as configuration changes. This tip is especially helpful when upstream flows are expensive to create and when these operators are used in ViewModels.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;buffering-events&quot;&gt;Buffering events&lt;/h2&gt;

&lt;p&gt;For this example, our requirements have changed, and now we’re asked to always listen for location updates and display the last 10 locations on the screen when the app comes from the background:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;locationDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;locations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;locationDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locationsSource&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;shareIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SharingStarted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Eagerly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;replay&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We use a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;replay&lt;/code&gt; value of 10 to keep the last 10 emitted items in memory and re-emit those every time a collector observes the flow. To keep the underlying flow active all the time and emitting location updates, use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SharingStarted.Eagerly&lt;/code&gt; policy to listen for updates even if there are no collectors.&lt;/p&gt;

&lt;h2 id=&quot;caching-data&quot;&gt;Caching data&lt;/h2&gt;

&lt;p&gt;Our requirements have changed again, and in this case, we don’t need to be &lt;em&gt;always&lt;/em&gt; listening for location updates if the app is in the background. However, we need to cache the last emitted item so that the user always sees some data on the screen, even if stale, while getting the current location. For this case, we can use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateIn&lt;/code&gt; operator.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;locationDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;locations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;locationDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locationsSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stateIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WhileSubscribed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EmptyLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow.stateIn&lt;/code&gt; caches and replays the last emitted item to a new collector.&lt;/p&gt;

&lt;h2 id=&quot;watch-out-do-not-create-new-instances-on-each-function-call&quot;&gt;WATCH OUT! Do not create new instances on each function call&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;NEVER&lt;/strong&gt; use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shareIn&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateIn&lt;/code&gt; to create a new flow that’s returned when calling a function. That’d create a new &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SharedFlow&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateFlow&lt;/code&gt; on each function invocation that will remain in memory until the scope is cancelled or is garbage collected when there are no references to it.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;userLocalDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserLocalDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// DO NOT USE shareIn or stateIn in a function like this.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// It creates a new SharedFlow/StateFlow per invocation which is not reused!&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;userLocalDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;shareIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WhileSubscribed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;    

    &lt;span class=&quot;c1&quot;&gt;// DO USE shareIn or stateIn in a property&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;userLocalDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;shareIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WhileSubscribed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;flows-that-require-input&quot;&gt;Flows that require input&lt;/h2&gt;

&lt;p&gt;Flows that require input, like a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;userId&lt;/code&gt;, cannot be shared easily using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shareIn&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateIn&lt;/code&gt;. Taking as an example the &lt;a href=&quot;https://github.com/google/iosched&quot;&gt;iosched&lt;/a&gt; open-source project — Google I/O’s Android app — the flow to get user events from &lt;a href=&quot;https://firebase.google.com/docs/firestore/quickstart&quot;&gt;Firestore&lt;/a&gt; is implemented using a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt;, as you can see &lt;a href=&quot;https://github.com/google/iosched/blob/main/shared/src/main/java/com/google/samples/apps/iosched/shared/data/userevent/FirestoreUserEventDataSource.kt#L107&quot;&gt;in the source code&lt;/a&gt;. As it takes the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;userId&lt;/code&gt; as a parameter, this flow cannot be reused easily using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shareIn&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateIn&lt;/code&gt; operators.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;userEventsDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FirestoreUserEventDataSource&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// New collectors will register as a new callback in Firestore.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// As this function depends on a `userId`, the flow cannot be&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// reused by calling shareIn or stateIn in this function.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// That will cause a new Shared/StateFlow to be created&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// every time the function is called.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getUserEvents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;UserEventsResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;userLocalDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getObservableUserEvents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Optimizing this use case depends on the requirements of your app:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Do you allow receiving events from multiple users at the same time? You might need to create a map of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SharedFlow&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateFlow&lt;/code&gt; instances, and remove the reference and cancel the upstream flow when the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subscriptionCount&lt;/code&gt; reaches zero.&lt;/li&gt;
  &lt;li&gt;If you allow only one user, and all collectors need to update to the new user, you could emit event updates to a common &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SharedFlow&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateFlow&lt;/code&gt; for all collectors and use the common flow as a variable in the class.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shareIn&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateIn&lt;/code&gt; operators can be used with cold flows to improve performance, add a buffer when collectors are not present, or even as a caching mechanism! Use them wisely, and don’t create new instances on each function call — it won’t work as you’d expect!&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Manuel Vivo</name>
        
        
      </author>

      

      
        <category term="coroutines" />
      

      
        <summary type="html">Become familiar with the shareIn and stateIn operators by example.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">A safer way to collect flows from Android UIs</title>
      <link href="https://manuelvivo.dev/coroutines-addrepeatingjob" rel="alternate" type="text/html" title="A safer way to collect flows from Android UIs" />
      <published>2021-03-26T00:00:00+00:00</published>
      <updated>2021-03-26T00:00:00+00:00</updated>
      <id>https://manuelvivo.dev/coroutines-addrepeatingjob</id>
      <content type="html" xml:base="https://manuelvivo.dev/coroutines-addrepeatingjob">&lt;p&gt;Learn how to use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lifecycle.repeatOnLifecycle&lt;/code&gt; API to safely collect flows from the UI layer in Android.&lt;/p&gt;

&lt;p&gt;In an Android app, &lt;a href=&quot;https://developer.android.com/kotlin/flow&quot;&gt;Kotlin flows&lt;/a&gt; are typically collected from the UI layer to display data updates on the screen. However, you want to collect these flows making sure you’re not doing more work than necessary, wasting resources (both CPU and memory) or leaking data when the view goes to the background.&lt;/p&gt;

&lt;p&gt;In this article, you’ll learn how the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lifecycle.repeatOnLifecycle&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow.flowWithLifecycle&lt;/code&gt; APIs protect you from wasting resources and why they’re a good default to use for flow collection in the UI layer.&lt;/p&gt;

&lt;h2 id=&quot;wasting-resources&quot;&gt;Wasting resources&lt;/h2&gt;

&lt;p&gt;It’s &lt;a href=&quot;https://developer.android.com/kotlin/coroutines/coroutines-best-practices#coroutines-data-layer&quot;&gt;recommended&lt;/a&gt; to expose the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow&amp;lt;T&amp;gt;&lt;/code&gt; API from lower layers of your app hierarchy regardless of the flow producer implementation details. However, you should also collect them safely.&lt;/p&gt;

&lt;p&gt;A cold flow backed by a &lt;a href=&quot;https://kotlinlang.org/docs/channels.html&quot;&gt;channel&lt;/a&gt; or using operators with buffers such as &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buffer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;conflate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flowOn&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/share-in.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shareIn&lt;/code&gt;&lt;/a&gt; is &lt;strong&gt;not safe to collect&lt;/strong&gt; with some of the existing APIs such as &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope.launch&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/launch-in.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow&amp;lt;T&amp;gt;.launchIn&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleCoroutineScope&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LifecycleCoroutineScope.launchWhenX&lt;/code&gt;&lt;/a&gt;, unless you manually cancel the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Job&lt;/code&gt; that started the coroutine when the activity goes to the background. These APIs will keep the underlying flow producer active while emitting items into the buffer in the background, and thus wasting resources.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: A &lt;strong&gt;cold&lt;/strong&gt; flow is a type of flow that executes the producer block of code on-demand when a new subscriber collects.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For example, consider this flow that emits Location updates using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/callback-flow.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Implementation of a cold flow backed by a Channel that sends Location updates&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FusedLocationProviderClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callbackFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;callback&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;: &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LocationCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onLocationResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;offer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lastLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;requestLocationUpdates&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;createLocationRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Looper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getMainLooper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;addOnFailureListener&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// in case of exception, close the Flow&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// clean up when Flow collection ends&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;awaitClose&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;removeLocationUpdates&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: Internally, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt; uses a &lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines/channels.html&quot;&gt;channel&lt;/a&gt;, which is conceptually very similar to a blocking &lt;a href=&quot;https://en.wikipedia.org/wiki/Queue_(abstract_data_type)&quot;&gt;queue&lt;/a&gt;, and has a default capacity of 64 elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Collecting this flow from the UI layer using any of the aforementioned APIs keeps the flow emitting locations even if the view is not displaying them in the UI! See the example below:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Collects from the flow when the View is at least STARTED and&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// SUSPENDS the collection when the lifecycle is STOPPED.&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Collecting the flow cancels when the View is DESTROYED.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;lifecycleScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launchWhenStarted&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;locationProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;collect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// New location! Update the map&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Same issue with:&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// - lifecycleScope.launch { /* Collect from locationFlow() here */ }&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// - locationProvider.locationFlow().onEach { /* ... */ }.launchIn(lifecycleScope)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lifecycleScope.launchWhenStarted&lt;/code&gt; suspends the execution of the coroutine. New locations are not processed, but the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt; producer keeps sending locations nonetheless. Using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lifecycleScope.launch&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;launchIn&lt;/code&gt; APIs are even more dangerous as the view keeps consuming locations even if it’s in the background! Which could potentially make your app crash.&lt;/p&gt;

&lt;p&gt;To solve this issue with these APIs, you’d need to manually cancel collection when the view goes to the background to cancel the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt; and avoid the location provider emitting items and wasting resources. For example, you could do something like the following:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Coroutine listening for Locations&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;locationUpdatesJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;locationUpdatesJob&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lifecycleScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;locationProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;collect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// New location! Update the map&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onStop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Stop collecting when the View goes to the background&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;locationUpdatesJob&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onStop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That’s a good solution, but that’s boilerplate, friends! And if there’s a universal truth about Android developers, it’s that we absolutely detest writing boilerplate code. One of the biggest benefits of not having to write boilerplate code is that with less code, there are fewer chances of making a mistake!&lt;/p&gt;

&lt;h2 id=&quot;lifecyclerepeatonlifecycle&quot;&gt;Lifecycle.repeatOnLifecycle&lt;/h2&gt;

&lt;p&gt;Now that we all are on the same page and know where the problem lies, it’s time to come up with a solution. The solution needs to be 1) simple, 2) friendly or easy to remember/understand, and more importantly 3) safe! It should work for all use cases regardless of the flow implementation details.&lt;/p&gt;

&lt;p&gt;Without further ado, the API you should use is &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lifecycle.repeatOnLifecycle&lt;/code&gt;&lt;/strong&gt; available in the &lt;a href=&quot;https://developer.android.com/jetpack/androidx/releases/lifecycle&quot;&gt;&lt;em&gt;lifecycle-runtime-ktx&lt;/em&gt;&lt;/a&gt; library.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: This API is available in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lifecycle:lifecycle-runtime-ktx:2.4.0-alpha01&lt;/code&gt; library or later.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Take a look at the following code:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Create a new coroutine since repeatOnLifecycle is a suspend function&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;lifecycleScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// The block passed to repeatOnLifecycle is executed when the lifecycle&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// is at least STARTED and is cancelled when the lifecycle is STOPPED.&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// It automatically restarts the block when the lifecycle is STARTED again.&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;repeatOnLifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;STARTED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// Safely collect from locationFlow when the lifecycle is STARTED&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// and stops collection when the lifecycle is STOPPED&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;locationProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;collect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// New location! Update the map&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; is a suspend function that takes a &lt;a href=&quot;https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lifecycle.State&lt;/code&gt;&lt;/a&gt; as a parameter that is used to &lt;strong&gt;automatically create and launch a new coroutine&lt;/strong&gt; with the block passed to it when the lifecycle reaches that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt;, and &lt;strong&gt;cancel the ongoing coroutine&lt;/strong&gt; when the lifecycle falls below the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This avoids any boilerplate code since the associated code to cancel the coroutine when it’s no longer needed is automatically done by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt;. As you could guess, it’s recommended to call this API in the activity’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onCreate&lt;/code&gt; or fragment’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onViewCreated&lt;/code&gt; methods to avoid unexpected behaviors. See the example below using fragments:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationFragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Fragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onViewCreated&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;View&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;viewLifecycleOwner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lifecycleScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;viewLifecycleOwner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;repeatOnLifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;STARTED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;locationProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;collect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// New location! Update the map&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Important&lt;/strong&gt;: Fragments should always use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;viewLifecycleOwner&lt;/code&gt; to trigger UI updates. However, that’s not the case for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DialogFragment&lt;/code&gt;s which might not have a View sometimes. For &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DialogFragment&lt;/code&gt;s, you can use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lifecycleOwner&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: This API is available in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lifecycle:lifecycle-runtime-ktx:2.4.0-alpha01&lt;/code&gt; library or later.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;under-the-hood&quot;&gt;Under the hood&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; suspends the calling coroutine, re-launches the block when the lifecycle moves in and out of the target &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt; in a &lt;em&gt;new&lt;/em&gt; coroutine, and &lt;strong&gt;resumes the calling coroutine when the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lifecycle&lt;/code&gt; is destroyed&lt;/strong&gt;. This last point is very important: the coroutine that calls &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; won’t resume executing until the lifecycle is destroyed.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Create a coroutine&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;lifecycleScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            
            &lt;span class=&quot;n&quot;&gt;lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;repeatOnLifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;RESUMED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// Repeat when the lifecycle is RESUMED, cancel when PAUSED&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// `lifecycle` is DESTROYED when the coroutine resumes. repeatOnLifecycle&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// suspends the execution of the coroutine until the lifecycle is DESTROYED.&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;visual-diagram&quot;&gt;Visual diagram&lt;/h2&gt;

&lt;p&gt;Circling back to the beginning, collecting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;locationFlow&lt;/code&gt; directly from a coroutine started with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lifecycleScope.launch&lt;/code&gt; is dangerous since the collection keeps happening even when the View is in the background.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; prevents you from wasting resources and app crashes because it stops and restarts the flow collection when the lifecycle moves in and out of the target state.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/images/2021-03-26-coroutines-addrepeatingjob_2.png&quot; alt=&quot;img&quot; /&gt;
&lt;small&gt;Difference between using and not using the repeatOnLifecycle API.&lt;/small&gt;&lt;/p&gt;

&lt;h2 id=&quot;flowflowwithlifecycle&quot;&gt;Flow.flowWithLifecycle&lt;/h2&gt;

&lt;p&gt;You can also use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow.flowWithLifecycle&lt;/code&gt; operator when you have only one flow to collect. This API uses the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lifecycle.repeatOnLifecycle&lt;/code&gt; API under the hood, and emits items and cancels the underlying producer when the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lifecycle&lt;/code&gt; moves in and out of the target state.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;locationProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;flowWithLifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;STARTED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onEach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// New location! Update the map&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launchIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lifecycleScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: This API name takes the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow.flowOn(CoroutineContext)&lt;/code&gt; operator as a precedent since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow.flowWithLifecycle&lt;/code&gt; changes the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineContext&lt;/code&gt; used to collect the upstream flow while leaving the downstream unaffected. Also, similar to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flowOn&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow.flowWithLifecycle&lt;/code&gt; adds a buffer in case the consumer doesn’t keep up with the producer. This is due to the fact that its implementation uses a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;configuring-the-underlying-producer&quot;&gt;Configuring the underlying producer&lt;/h2&gt;

&lt;p&gt;Even if you use these APIs, watch out for hot flows that could waste resources even if they aren’t collected by anyone! There are some valid use cases for them, but do keep that in mind and document it if needed. Having the underlying flow producer active in the background, even if wasting resources, can be beneficial for some use cases: you instantly have fresh data available rather than &lt;em&gt;catching up&lt;/em&gt; and temporarily showing stale data. &lt;strong&gt;Depending on the use case, decide whether the producer needs to be always active or not&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MutableStateFlow&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MutableSharedFlow&lt;/code&gt; APIs expose a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subscriptionCount&lt;/code&gt; field that you can use to stop the underlying producer when &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subscriptionCount&lt;/code&gt; is zero. By default, they will keep the producer active as long as the object that holds the flow instance is in memory. There are some valid use cases for this though, for example, a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UiState&lt;/code&gt; exposed from the ViewModel to the UI using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateFlow&lt;/code&gt;. That’s ok! This use case demands the ViewModel to always provide the latest UI state to the View.&lt;/p&gt;

&lt;p&gt;Similarly, the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/state-in.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow.stateIn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/share-in.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow.shareIn&lt;/code&gt;&lt;/a&gt; operators can be configured with the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/index.html&quot;&gt;sharing started policy&lt;/a&gt; for this. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/-while-subscribed.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WhileSubscribed()&lt;/code&gt;&lt;/a&gt; will stop the underlying producer when there are no active observers! On the contrary, &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/-eagerly.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Eagerly&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/-lazily.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lazily&lt;/code&gt;&lt;/a&gt; will keep the underlying producer active as long as the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt; they use is active.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: The APIs shown in this article are a good default to collect flows from the UI and should be used regardless of the flow implementation detail. These APIs do what they need to do: stop collecting if the UI isn’t visible on screen. It’s up to the flow implementation if it should be always active or not.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;safe-flow-collection-in-jetpack-compose&quot;&gt;Safe Flow collection in Jetpack Compose&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#collectasstate&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow.collectAsState&lt;/code&gt;&lt;/a&gt; function is used in Compose to collect flows from composables and represent the values as &lt;a href=&quot;https://developer.android.com/reference/kotlin/androidx/compose/runtime/State&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;State&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; to be able to update Compose UI. Even if Compose doesn’t recompose the UI when the host activity or fragment is in the background, the flow producer is still active and can waste resources. Compose can suffer from the same problem as the View system.&lt;/p&gt;

&lt;p&gt;When collecting flows in Compose, use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow.flowWithLifecycle&lt;/code&gt; operator as follows:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Composable&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LocationScreen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;lifecycleOwner&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocalLifecycleOwner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;locationFlowLifecycleAware&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;remember&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lifecycleOwner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;flowWithLifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lifecycleOwner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;STARTED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;locationFlowLifecycleAware&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;collectAsState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Current location, do something with it&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Notice that you &lt;a href=&quot;https://developer.android.com/jetpack/compose/state&quot;&gt;need to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remember&lt;/code&gt;&lt;/a&gt; the flow that is aware of the lifecycle with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;locationFlow&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lifecycleOwner&lt;/code&gt; as keys to always use the same flow unless one of the keys change.&lt;/p&gt;

&lt;p&gt;In Compose, side effects must be performed in a &lt;a href=&quot;https://developer.android.com/jetpack/compose/lifecycle#state-effect-use-cases&quot;&gt;controlled environment&lt;/a&gt;. For that, use &lt;a href=&quot;https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#launchedeffect_1&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LaunchedEffect&lt;/code&gt;&lt;/a&gt; to create a coroutine that follows the composable’s lifecycle. In its block, you could call the suspend &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lifecycle.repeatOnLifecycle&lt;/code&gt; if you need it to re-launch a block of code when the host lifecycle is in a certain &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;State&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;comparison-with-livedata&quot;&gt;Comparison with LiveData&lt;/h2&gt;

&lt;p&gt;You might’ve noticed that this API behaves similarly to &lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/livedata&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt;&lt;/a&gt;, and that’s true! &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt; is aware of Lifecycle, and its restarting behavior makes it ideal for observing streams of data from the UI. And that’s also the case for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lifecycle.repeatOnLifecycle&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow.flowWithLifecycle&lt;/code&gt; APIs!&lt;/p&gt;

&lt;p&gt;Collecting flows using these APIs is a natural replacement for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt; in &lt;em&gt;Kotlin-only&lt;/em&gt; apps. If you use these APIs for flow collection, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt; doesn’t offer any benefits over coroutines and flow. Even more, flows are more flexible since they can be collected from any &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt; and they can be powered with &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/&quot;&gt;all its operators&lt;/a&gt;. As opposed to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt;, which has limited operators available and whose values are always observed from the UI thread.&lt;/p&gt;

&lt;h3 id=&quot;stateflow-support-in-data-binding&quot;&gt;StateFlow support in data binding&lt;/h3&gt;

&lt;p&gt;On a different note, one of the reasons you might be using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt; is because it’s supported by data binding. Well, so is &lt;a href=&quot;https://developer.android.com/kotlin/flow/stateflow-and-sharedflow&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateFlow&lt;/code&gt;&lt;/a&gt;! For more information about &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateFlow&lt;/code&gt; support in data binding, &lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/observability#stateflow&quot;&gt;check out the official documentation&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lifecycle.repeatOnLifecycle&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flow.flowWithLifecycle&lt;/code&gt; APIs to safely collect flows from the UI layer in Android.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Manuel Vivo</name>
        
        
      </author>

      

      
        <category term="coroutines" />
      

      
        <summary type="html">Learn how to use the Lifecycle.repeatOnLifecycle API to safely collect flows from the UI layer in Android.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Bridging the gap between coroutines, JVM threads, and concurrency problems</title>
      <link href="https://manuelvivo.dev/coroutines-and-threads" rel="alternate" type="text/html" title="Bridging the gap between coroutines, JVM threads, and concurrency problems" />
      <published>2021-02-03T00:00:00+00:00</published>
      <updated>2021-02-03T00:00:00+00:00</updated>
      <id>https://manuelvivo.dev/coroutines-and-threads</id>
      <content type="html" xml:base="https://manuelvivo.dev/coroutines-and-threads">&lt;p&gt;Learn more about how coroutines are executed in the JVM and concurrency problems.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Coroutines are light-weight threads”&lt;/em&gt;, how many times have you read that? Does that mean anything to you? Probably not. Keep reading to learn more about &lt;strong&gt;how coroutines are actually executed in the JVM&lt;/strong&gt;, how they relate to threads, and the &lt;strong&gt;concurrency issues&lt;/strong&gt; that are inevitable when using the JVM threading model.&lt;/p&gt;

&lt;h2 id=&quot;coroutines-and-jvmthreads&quot;&gt;Coroutines and JVM threads&lt;/h2&gt;

&lt;p&gt;Coroutines aim to simplify code that executes asynchronously. When talking about coroutines in the JVM, &lt;strong&gt;the block of code passed as a lambda to a coroutine builder ultimately gets executed on a specific JVM thread&lt;/strong&gt;. For example, this simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Fibonacci_number&quot;&gt;Fibonacci&lt;/a&gt; calculation:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Coroutine that calculates the 10th Fibonacci number in a background thread&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;someScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;fibonacci10&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;synchronousFibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;saveFibonacciInMemory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fibonacci10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;synchronousFibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The above &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;async&lt;/code&gt; coroutine’s block of code, that performs a synchronous and blocking fibonacci calculation and saves it to memory, &lt;strong&gt;gets dispatched and scheduled for execution in a thread pool managed by the coroutines library&lt;/strong&gt;, the one configured for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dispatchers.Default&lt;/code&gt;. The code will be executed in a thread of the thread pool at some time in the future depending on the thread pool’s policies.&lt;/p&gt;

&lt;p&gt;Note that the code above executes in one thread because it doesn’t suspend. It’s possible for one coroutine to be executed in different threads if the execution is moved to a different dispatcher, or if the block contains code that may yield/suspend in a dispatcher that uses a thread pool.&lt;/p&gt;

&lt;p&gt;Similarly, without coroutines, you could execute the logic above using threads manually as follows:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Create a thread pool of 4 threads&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;executorService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;newFixedThreadPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Schedule and execute this code in one of those threads&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;executorService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;execute&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;fibonacci10&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;synchronousFibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;saveFibonacciInMemory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fibonacci10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;While doing things on your own managing thread pools manually is possible, &lt;strong&gt;coroutines is the recommended solution for asynchronous programming on Android&lt;/strong&gt; due to the built-in cancellation support, easier error handling, &lt;em&gt;structured concurrency&lt;/em&gt; which reduces the likelihood of memory leaks, and its integration with Jetpack libraries.&lt;/p&gt;

&lt;h3 id=&quot;under-thehood&quot;&gt;Under the hood&lt;/h3&gt;

&lt;p&gt;What happens from the moment you create a coroutine until it gets executed on a thread? When you create a coroutine using the standard coroutine builders, you can specify on which &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/CoroutineDispatcher.kt&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt;&lt;/a&gt; to run it on; if not, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dispatchers.Default&lt;/code&gt; is used.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The CoroutineDispatcher is in charge of dispatching the execution of a coroutine to a JVM thread&lt;/strong&gt;. Under the hood, when a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt; is used, it intercepts the coroutine using this &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/CoroutineDispatcher.kt#L99&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;interceptContinuation&lt;/code&gt;&lt;/a&gt; method that &lt;strong&gt;wraps the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Continuation&lt;/code&gt; (i.e. the coroutine) in a &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/internal/DispatchedContinuation.kt&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DispatchedContinuation&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;. This is possible because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt; implements the &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/stdlib-stubs/src/ContinuationInterceptor.kt&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ContinuationInterceptor&lt;/code&gt;&lt;/a&gt; interface.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you read my article about &lt;a href=&quot;https://manuelvivo.dev/suspend-modifier&quot;&gt;how coroutines work under the hood&lt;/a&gt;, you already know that the compiler creates a state machine, and the information of the state machine (e.g. what needs to be executed next) is kept in a &lt;a href=&quot;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-continuation.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Continuation&lt;/code&gt;&lt;/a&gt; object.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In case a Continuation needs to be executed in a different Dispatcher, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DispatchedContinuation&lt;/code&gt;’s &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/internal/DispatchedContinuation.kt#L178&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resumeWith&lt;/code&gt;&lt;/a&gt; method is in charge of dispatching the coroutine to the appropriate one!&lt;/p&gt;

&lt;p&gt;Furthermore, a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DispatchedContinuation&lt;/code&gt; extends from the &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/internal/DispatchedTask.kt&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DispatchedTask&lt;/code&gt;&lt;/a&gt; abstract class which, in the JVM implementation, is a type that implements the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Runnable&lt;/code&gt; interface. Therefore, a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DispatchedContinuation&lt;/code&gt; can run on a JVM thread! How cool is that? When a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt; is specified, the coroutine is transformed to a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DispatchedTask&lt;/code&gt; that is dispatched to be executed on a JVM thread as a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;!&lt;/p&gt;

&lt;p&gt;And now… How does the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispatch&lt;/code&gt; method get called when you create a coroutine? When you create a coroutine using the standard coroutine builders, you can specify how the coroutine starts with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start&lt;/code&gt; parameter of type &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/index.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineStart&lt;/code&gt;&lt;/a&gt;. For example, you can configure it to start only when it’s needed, with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineStart.LAZY&lt;/code&gt;. By default, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineStart.DEFAULT&lt;/code&gt; is used which schedules the coroutine for execution according to its &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt;. Bingo!&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img width=&quot;1000&quot; src=&quot;assets/images/2021-02-03-coroutines-and-threads_1.png&quot; /&gt;
  &lt;small&gt;Illustration of how the block of code in a coroutine ends up executing in a Thread&lt;/small&gt;
&lt;/p&gt;

&lt;h3 id=&quot;dispatchers-and-threadpools&quot;&gt;Dispatchers and thread pools&lt;/h3&gt;

&lt;p&gt;You can execute coroutines in any of your app thread pools by converting them to a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt; using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.util.concurrent.-executor/as-coroutine-dispatcher.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executor.asCoroutineDispatcher()&lt;/code&gt;&lt;/a&gt; extension function. Alternatively, you can use the default &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/Dispatchers.kt&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dispatchers&lt;/code&gt;&lt;/a&gt; that come in the coroutines library.&lt;/p&gt;

&lt;p&gt;You can see how &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dispatchers.Default&lt;/code&gt; is initialized in this &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/CoroutineContext.kt#L22&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;createDefaultDispatcher&lt;/code&gt;&lt;/a&gt; method. By default, the &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/scheduling/Dispatcher.kt&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DefaultScheduler&lt;/code&gt;&lt;/a&gt; is used. If you check out the implementation of &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/Dispatchers.kt#L118&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dispatchers.IO&lt;/code&gt;&lt;/a&gt;, it also uses the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DefaultScheduler&lt;/code&gt; and allows at least 64 threads to be created on demand. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dispatchers.Default&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dispatchers.IO&lt;/code&gt; are implicitly linked together as they use the same thread pool which brings me to the next topic. What’s the runtime overhead of calling &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;withContext&lt;/code&gt; with different Dispatchers?&lt;/p&gt;

&lt;h3 id=&quot;threads-and-withcontext-performance&quot;&gt;Threads and withContext performance&lt;/h3&gt;

&lt;p&gt;In the JVM, if there are more threads created than CPU cores available, switching between threads carries some runtime overhead. &lt;a href=&quot;https://en.wikipedia.org/wiki/Context_switch&quot;&gt;&lt;em&gt;Context switches&lt;/em&gt;&lt;/a&gt; aren’t cheap! The OS needs to save and restore the execution context, and the CPU needs to spend time scheduling threads instead of running actual app work. Apart from that, context switches may happen if a thread is running code that blocks. If that’s the case for threads, is there any performance penalty of using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;withContext&lt;/code&gt; with different Dispatchers?&lt;/p&gt;

&lt;p&gt;Fortunately, as you could imagine, thread pools manage all of this complexity for us, trying to optimize work to be executed as much as possible (that’s why executing work on a thread pool is better than doing so in threads manually). Coroutines also benefit from this as they’re scheduled in thread pools! On top of that, coroutines don’t block threads, they &lt;em&gt;suspend&lt;/em&gt; their work instead! Even more efficient!&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/scheduling/CoroutineScheduler.kt&quot;&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScheduler&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;, which is the thread pool used in the JVM implementation by default, &lt;strong&gt;distributes dispatched coroutines to worker threads in the most efficient manner&lt;/strong&gt;. As &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dispatchers.Default&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dispatchers.IO&lt;/code&gt; use the same thread pool, switching between them is optimized to avoid thread switches whenever possible. The coroutines library can optimize those calls, stay on the same dispatcher and thread, and follow a fast-path.&lt;/p&gt;

&lt;p&gt;As &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dispatchers.Main&lt;/code&gt; is usually a different thread in UI apps, switching between &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dispatchers.Default&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dispatchers.Main&lt;/code&gt; in coroutines doesn’t come with huge performance costs as the coroutine just suspends (i.e. stops executing in one thread), and gets scheduled to be executed in a different thread.&lt;/p&gt;

&lt;h2 id=&quot;concurrency-problems-in-coroutines&quot;&gt;Concurrency problems in coroutines&lt;/h2&gt;

&lt;p&gt;Coroutines DO make asynchronous programming easier due to how simple scheduling work on different threads is. On the other hand, this simplicity can be a double-edged sword: &lt;strong&gt;as coroutines run on the JVM threading model, they cannot simply escape from the concurrency problems that the threading model entails&lt;/strong&gt;. Thus, you have to pay attention to avoid this.&lt;/p&gt;

&lt;p&gt;Over the years, good practices like immutability have mitigated some of the thread-related issues that you can face. However, there are some cases that cannot be avoided with immutability. The mother of all concurrency problems is state management! In particular, accessing &lt;strong&gt;&lt;em&gt;mutable state&lt;/em&gt;&lt;/strong&gt; in a multi-threaded environment.&lt;/p&gt;

&lt;p&gt;The ordering of operations in a multi-threaded app is unpredictable. Apart from compiler optimizations that can reorder operations, threads are not guaranteed to be run in a particular order, and context switches can happen at any time. If the necessary precautions are not taken when accessing mutable state, threads could see stale data, lose updates, or suffer from &lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition&quot;&gt;&lt;em&gt;race conditions&lt;/em&gt;&lt;/a&gt; among other things.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note that the discussion of mutable state and access order isn’t specific to the JVM. They affect coroutines on other platforms, too.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;An app using coroutines is a multi-threaded app by nature. &lt;strong&gt;Classes that use coroutines and contain mutable state must take precautions to be predictable&lt;/strong&gt;, i.e. ensure the code executed in coroutines see the most up-to-date version of the data. In this way, different threads won’t interfere with one another. Concurrency issues can lead to very subtle bugs very hard to debug in your apps, even &lt;a href=&quot;https://en.wikipedia.org/wiki/Heisenbug&quot;&gt;&lt;em&gt;heisenbugs&lt;/em&gt;&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;These types of classes are not uncommon. Maybe the class needs to keep the information of the logged-in user in memory, or cache some values while the app is alive. Concurrency issues can still happen in coroutines if you’re not careful! A suspend function using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;withContext(defaultDispatcher)&lt;/code&gt; is not guaranteed to be executed always in the same thread!&lt;/p&gt;

&lt;p&gt;Let’s say we have a class that caches transactions made by users. If the cache is not accessed properly, like for example below, concurrency bugs can happen:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TransactionsRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;defaultDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineDispatcher&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Default&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;transactionsCache&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutableMapOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// CAREFUL! Access to the cache is not protected.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Concurrency bugs can happen: threads can see stale data&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// and race conditions may occur.&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;withContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;defaultDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;oldList&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;newList&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;toMutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Even if we’re talking about Kotlin, the book Java concurrency in practice by Brian Goetz is a great resource to learn more about this topic and the intricacies of concurrency in JVM systems. Alternatively, Jetbrains has documentation about &lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines/shared-mutable-state-and-concurrency.html&quot;&gt;shared mutable state and concurrency&lt;/a&gt; too.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;protecting-mutablestate&quot;&gt;Protecting mutable state&lt;/h3&gt;

&lt;p&gt;How to protect mutable state, or find a good &lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronization_(computer_science)&quot;&gt;&lt;em&gt;synchronization&lt;/em&gt;&lt;/a&gt; policy, totally depends on the nature of the data and the operations involved. This section is about bringing awareness of the concurrency issues you can face instead of listing all the different ways and APIs to protect mutable state. Nonetheless, here’s some tips and APIs you can start with to make your mutable variables thread-safe.&lt;/p&gt;

&lt;h4 id=&quot;encapsulation&quot;&gt;Encapsulation&lt;/h4&gt;

&lt;p&gt;Mutable state should be encapsulated and &lt;em&gt;owned&lt;/em&gt; by a class. This class centralizes access to the state, and will protect reads and writes with the synchronization policy that better fits the use case.&lt;/p&gt;

&lt;h4 id=&quot;thread-confinement&quot;&gt;Thread confinement&lt;/h4&gt;

&lt;p&gt;A solution can be to restrict read/write access to one thread. Access to the mutable state can be done in a producer/consumer way using a queue. JetBrains has &lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines/shared-mutable-state-and-concurrency.html#thread-confinement-fine-grained&quot;&gt;good documentation&lt;/a&gt; about this.&lt;/p&gt;

&lt;h4 id=&quot;dont-reinvent-thewheel&quot;&gt;Don’t reinvent the wheel&lt;/h4&gt;

&lt;p&gt;In the JVM, there are thread-safe data structures you can use to protect your mutable variables. For example, for the case of a simple counter, you can use &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AtomicInteger&lt;/code&gt;&lt;/a&gt;. Or, to protect the map of the code snippet above, you could use a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;&lt;/a&gt;. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt; is a thread-safe, synchronized collection that optimizes the throughput of reads and writes to the map.&lt;/p&gt;

&lt;p&gt;Note that thread-safe data structures don’t guard against caller ordering problems, they just make sure memory access is atomic. They help avoid using locks when the logic is not too complicated. For example, they can’t be used in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;transactionCache&lt;/code&gt; example shown above because the order of operations and the logic between them need thread and access protection.&lt;/p&gt;

&lt;p&gt;Also, data in these thread-safe data structures needs to be immutable or protected to prevent race conditions when modifying objects already stored in them.&lt;/p&gt;

&lt;h4 id=&quot;custom-solutions&quot;&gt;Custom solutions&lt;/h4&gt;

&lt;p&gt;If you have compound actions that need to be synchronized, &lt;a href=&quot;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-volatile/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Volatile&lt;/code&gt;&lt;/a&gt; variables or thread-safe data structures won’t help! And it’s possible that the built-in &lt;a href=&quot;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-synchronized/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Synchronized&lt;/code&gt;&lt;/a&gt; annotation is not granular enough to make your use case efficient.&lt;/p&gt;

&lt;p&gt;In those cases, you might need to create your own synchronization mechanism using concurrent utilities such as &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html&quot;&gt;latches&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Semaphore_(programming)&quot;&gt;semaphores&lt;/a&gt;, or &lt;a href=&quot;https://en.wikipedia.org/wiki/Barrier_(computer_science)&quot;&gt;barriers&lt;/a&gt;. Other times, you can unconditionally protect multi-threaded access to code using &lt;a href=&quot;https://en.wikipedia.org/wiki/Lock_(computer_science)&quot;&gt;locks&lt;/a&gt; or mutexes.&lt;/p&gt;

&lt;p&gt;A &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/index.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mutex&lt;/code&gt;&lt;/a&gt; in Kotlin has the suspend functions &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/lock.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/unlock.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unlock&lt;/code&gt;&lt;/a&gt; to manually protect parts of your coroutines code. Conveniently, the extension function &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mutex.withLock&lt;/code&gt;&lt;/a&gt; makes it easier to use:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TransactionsRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;defaultDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineDispatcher&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Default&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// Mutex protecting the cache mutable state&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;cacheMutex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;transactionsCache&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutableMapOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;withContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;defaultDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Mutex makes the read&amp;amp;write cache operation thread safe&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;cacheMutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;withLock&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;oldList&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
          &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;newList&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;toMutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;newList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As a coroutine using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mutex&lt;/code&gt; suspends execution until it can proceed, it’s much more efficient than a JVM lock that blocks the thread. Be careful about using JVM synchronization classes in coroutines as that can block the thread in which the coroutine is being executed and create &lt;a href=&quot;https://en.wikipedia.org/wiki/Liveness&quot;&gt;liveness&lt;/a&gt; issues.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The block of code passed to a coroutine builder ends up executing on one or multiple JVM threads. And as such, coroutines run on the JVM threading model with all its constraints. With coroutines, it’s still possible to write vulnerable wrong multi-threaded code. So, watch out for access to shared mutable state in your code!&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Manuel Vivo</name>
        
        
      </author>

      

      
        <category term="coroutines" />
      

      
        <summary type="html">Learn more about how coroutines are executed in the JVM and concurrency problems.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Simplifying APIs with coroutines and Flow</title>
      <link href="https://manuelvivo.dev/simplifying-apis-coroutines" rel="alternate" type="text/html" title="Simplifying APIs with coroutines and Flow" />
      <published>2020-12-16T00:00:00+00:00</published>
      <updated>2020-12-16T00:00:00+00:00</updated>
      <id>https://manuelvivo.dev/simplifying-apis-coroutines</id>
      <content type="html" xml:base="https://manuelvivo.dev/simplifying-apis-coroutines">&lt;p&gt;Learn how to create your own coroutine adapters and see how they work under the hood&lt;/p&gt;

&lt;p&gt;If you’re a library author, you might want to make your Java-based or callback-based libraries easier to consume from Kotlin using coroutines and Flow. Alternatively, if you’re an API consumer, you may be willing to adapt a 3rd party API surface to coroutines to make them more Kotlin friendly.&lt;/p&gt;

&lt;p&gt;This article covers how to simplify APIs using coroutines and Flow as well as how to build your own adapter using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;suspendCancellableCoroutine&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt; APIs. For the most curious ones, those APIs will be dissected and you’ll see how they work under the hood.&lt;/p&gt;

&lt;p&gt;If you prefer to watch a video about this topic, check this one out:&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/OmHePYcHbyQ&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h2 id=&quot;check-existing-coroutine-adapters&quot;&gt;Check existing coroutine adapters&lt;/h2&gt;

&lt;p&gt;Before writing your own wrappers for existing APIs, check if an adapter or &lt;a href=&quot;https://medium.com/androiddevelopers/extend-your-code-readability-with-kotlin-extensions-542bf702aa36&quot;&gt;extension function&lt;/a&gt; is available for your use case. There are existing libraries with coroutine adapters for common types.&lt;/p&gt;

&lt;h3 id=&quot;future-types&quot;&gt;Future types&lt;/h3&gt;

&lt;p&gt;For future types, there are integrations for Java 8’s &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/integration/kotlinx-coroutines-jdk8/src/future/Future.kt&quot;&gt;CompletableFuture&lt;/a&gt;, and Guava’s &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/integration/kotlinx-coroutines-guava/src/ListenableFuture.kt&quot;&gt;ListenableFuture&lt;/a&gt;. This is not an exhaustive list, search online if an adapter for your future type already exists.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Awaits completion of CompletionStage without blocking a thread&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CompletionStage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt; 

&lt;span class=&quot;c1&quot;&gt;// Awaits completion of ListenableFuture without blocking a thread&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ListenableFuture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With these functions, you can get rid of callbacks and just suspend the coroutine until the future result comes back.&lt;/p&gt;

&lt;h3 id=&quot;reactive-streams&quot;&gt;Reactive Streams&lt;/h3&gt;

&lt;p&gt;For reactive stream libraries, there are integrations for &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/tree/master/reactive/kotlinx-coroutines-rx3&quot;&gt;RxJava&lt;/a&gt;, &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/tree/master/reactive/kotlinx-coroutines-jdk9&quot;&gt;Java 9 APIs&lt;/a&gt;, and &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/tree/master/reactive/kotlinx-coroutines-reactive&quot;&gt;reactive streams&lt;/a&gt; libraries.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Transforms the given reactive Publisher into Flow.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Any&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Publisher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;asFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;These functions convert a reactive stream into Flow.&lt;/p&gt;

&lt;h3 id=&quot;android-specific-apis&quot;&gt;Android specific APIs&lt;/h3&gt;

&lt;p&gt;For Jetpack libraries or Android platform APIs, take a look at the &lt;a href=&quot;https://developer.android.com/kotlin/ktx/extensions-list&quot;&gt;Jetpack KTX libraries list&lt;/a&gt;. Currently, more than 20 libraries have a KTX version, creating sweet idiomatic versions of Java APIs, ranging from SharedPreferences to ViewModels, SQLite and even Play Core.&lt;/p&gt;

&lt;h3 id=&quot;callbacks&quot;&gt;Callbacks&lt;/h3&gt;

&lt;p&gt;Callbacks are a very common solution for asynchronous communication. In fact, we use them for the Java programming language solution in the &lt;a href=&quot;https://developer.android.com/guide/background/threading&quot;&gt;Running tasks in background thread guide&lt;/a&gt;. However, they come with some drawbacks: this design leads to nested callbacks which ends up in incomprehensible code. Also, error handling is more complicated as there isn’t an easy way to propagate them.&lt;/p&gt;

&lt;p&gt;In Kotlin, you can simplify calling callbacks using coroutines, but for that, you’ll need to build your own adapter.&lt;/p&gt;

&lt;h2 id=&quot;build-your-own-adapter&quot;&gt;Build your own adapter&lt;/h2&gt;

&lt;p&gt;If you don’t find an adapter for your use case, it’s usually quite straightforward to write your own. &lt;strong&gt;For one-shot async calls, use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;suspendCancellableCoroutine&lt;/code&gt;&lt;/a&gt; API. For streaming data, use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/callback-flow.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt;&lt;/a&gt; API&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;As an exercise, the following examples will use the &lt;a href=&quot;https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient.html&quot;&gt;Fused Location Provider&lt;/a&gt; API from Google Play Services to get location data. The API surface is simple but it uses callbacks to perform async operations. With coroutines, we can get rid of those callbacks that can quickly make our code unreadable when the logic gets complicated.&lt;/p&gt;

&lt;p&gt;In case you want to explore other solutions, you can get inspiration from the source code of all the functions linked above.&lt;/p&gt;

&lt;h3 id=&quot;one-shot-async-calls&quot;&gt;One-shot async calls&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&quot;https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient.html&quot;&gt;Fused Location Provider&lt;/a&gt; API provides the &lt;a href=&quot;https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient#getLastLocation()&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getLastLocation&lt;/code&gt;&lt;/a&gt; method to obtain the &lt;a href=&quot;https://developer.android.com/training/location/retrieve-current&quot;&gt;last known location&lt;/a&gt;. The ideal API for coroutines is a suspend function that returns exactly that.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note that this API returns a &lt;a href=&quot;https://developers.google.com/android/reference/com/google/android/gms/tasks/Task&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt;&lt;/a&gt; and there’s already an &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/integration/kotlinx-coroutines-play-services/src/Tasks.kt&quot;&gt;adapter&lt;/a&gt; available for it. However, for learning purposes, we’ll use it as an example.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We can have a better API by creating an extension function on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FusedLocationProviderClient&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FusedLocationProviderClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;awaitLastLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As this is a one-shot async operation, we use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;suspendCancellableCoroutine&lt;/code&gt; function: a low-level building block for creating suspending functions from the coroutines library.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;suspendCancellableCoroutine&lt;/code&gt; executes the block of code passed to it as a parameter, then suspends the coroutine execution while waiting for the signal to continue. The coroutine will resume executing when the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resume&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resumeWithException&lt;/code&gt; method is called in the coroutine’s &lt;a href=&quot;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-continuation/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Continuation&lt;/code&gt;&lt;/a&gt; object. For more information about continuations, check out the &lt;em&gt;&lt;a href=&quot;https://manuelvivo.dev/suspend-modifier&quot;&gt;suspend modifier under the hood article&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;We use the callbacks that can be added to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getLastLocation&lt;/code&gt; method to resume the coroutine appropriately. See the implementation below:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Extension function on FusedLocationProviderClient, returns last known location&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FusedLocationProviderClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;awaitLastLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// Create a new coroutine that can be cancelled&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;suspendCancellableCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;continuation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Add listeners that will resume the execution of this coroutine&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lastLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;addOnSuccessListener&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Resume coroutine and return location&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;continuation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;resume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;addOnFailureListener&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Resume the coroutine by throwing an exception&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;continuation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;resumeWithException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// End of the suspendCancellableCoroutine block. This suspends the&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// coroutine until one of the callbacks calls the continuation parameter.&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note: Although you will also find a non-cancellable version of this coroutine builder in the coroutines library (i.e. &lt;a href=&quot;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/suspend-coroutine.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;suspendCoroutine&lt;/code&gt;&lt;/a&gt;), it is preferable to always choose &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;suspendCancellableCoroutine&lt;/code&gt;&lt;/a&gt; to handle cancellation of the coroutine scope, or to propagate cancellation from the underlying API.&lt;/p&gt;

&lt;h4 id=&quot;suspendcancellablecoroutine-under-the-hood&quot;&gt;suspendCancellableCoroutine under the hood&lt;/h4&gt;

&lt;p&gt;Internally, &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/CancellableContinuation.kt#L305&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;suspendCancellableCoroutine&lt;/code&gt;&lt;/a&gt; uses &lt;a href=&quot;https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/coroutines/intrinsics/Intrinsics.kt#L41&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/code&gt;&lt;/a&gt; to get the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Continuation&lt;/code&gt; of the coroutine inside a suspend function. That &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Continuation&lt;/code&gt; object is intercepted by a &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/CancellableContinuation.kt&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CancellableContinuation&lt;/code&gt;&lt;/a&gt; that will control the lifecycle of that coroutine from that point (its &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/CancellableContinuationImpl.kt&quot;&gt;implementation&lt;/a&gt; has the functionality of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Job&lt;/code&gt; with some restrictions).&lt;/p&gt;

&lt;p&gt;After that, the lambda passed to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;suspendCancellableCoroutine&lt;/code&gt; will be executed and the coroutine will either resume immediately if the lambda returns a result or will be suspended until the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CancellableContinuation&lt;/code&gt; is resumed manually from the lambda.&lt;/p&gt;

&lt;p&gt;See my own comments in the following code snippet (following the &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/CancellableContinuation.kt#L305&quot;&gt;original implementation&lt;/a&gt;) to understand what’s happening:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;suspendCancellableCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;crossinline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;CancellableContinuation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Unit&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Get the Continuation object of the coroutine that it's running this suspend function&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uCont&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Take over the control of the coroutine. The Continuation's been&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// intercepted and it follows the CancellableContinuationImpl lifecycle now&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;cancellable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CancellableContinuationImpl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uCont&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;intercepted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;
 
    &lt;span class=&quot;c1&quot;&gt;// Call block of code with the cancellable continuation&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancellable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        
    &lt;span class=&quot;c1&quot;&gt;// Either suspend the coroutine and wait for the Continuation to be resumed&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// manually in `block` or return a result if `block` has finished executing&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cancellable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To know more about how suspend functions work under the hood, check out the &lt;em&gt;&lt;a href=&quot;https://manuelvivo.dev/suspend-modifier&quot;&gt;suspend modifier under the hood article&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;streaming-data&quot;&gt;Streaming data&lt;/h3&gt;

&lt;p&gt;If instead we wanted to receive periodic location updates (using the &lt;a href=&quot;https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient#requestLocationUpdates(com.google.android.gms.location.LocationRequest,%20com.google.android.gms.location.LocationCallback,%20android.os.Looper)&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;requestLocationUpdates&lt;/code&gt;&lt;/a&gt; function) whenever the user’s device moves in the real world, we’d need to create a stream of data using &lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines/flow.html&quot;&gt;Flow&lt;/a&gt;. The ideal API would look like this:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FusedLocationProviderClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To convert streaming callback-based APIs to Flow, use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/callback-flow.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt;&lt;/a&gt; flow builder that creates a new flow. In the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt; lambda, we’re in the context of a coroutine, therefore, suspend functions can be called. Unlike the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flow&lt;/code&gt;&lt;/a&gt; flow builder, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;channelFlow&lt;/code&gt; allows values to be emitted from a different &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineContext&lt;/code&gt; or outside a coroutine, with the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/offer.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;offer&lt;/code&gt;&lt;/a&gt; method.&lt;/p&gt;

&lt;p&gt;Normally, flow adapters using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt; follow these three generic steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Create the callback that adds elements into the flow using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;offer&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Register the callback.&lt;/li&gt;
  &lt;li&gt;Wait for the consumer to cancel the coroutine and unregister the callback.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Applying this recipe to this use case, we get the following implementation:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Send location updates to the consumer &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FusedLocationProviderClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callbackFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// A new Flow is created. This code executes in a coroutine!&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 1. Create callback and add elements into the flow&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;callback&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;: &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LocationCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onLocationResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Ignore null responses&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;nf&quot;&gt;offer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Send location to the flow&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// Location couldn't be sent to the flow &lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 2. Register the callback to get location updates by calling requestLocationUpdates&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;requestLocationUpdates&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;createLocationRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Looper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getMainLooper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;addOnFailureListener&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// in case of error, close the Flow&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 3. Wait for the consumer to cancel the coroutine and unregister&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// the callback. This suspends the coroutine until the Flow is closed.&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;awaitClose&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Clean up code goes here&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;removeLocationUpdates&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;callbackflow-under-the-hood&quot;&gt;callbackFlow under the hood&lt;/h4&gt;

&lt;p&gt;Internally, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt; uses a &lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines/channels.html&quot;&gt;channel&lt;/a&gt;, which is conceptually very similar to a blocking &lt;a href=&quot;https://en.wikipedia.org/wiki/Queue_(abstract_data_type)&quot;&gt;queue&lt;/a&gt;. A channel is configured with a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capacity&lt;/code&gt;: the number of elements that can be buffered. The channel created in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt; has the default capacity of 64 elements. When adding a new element to an already full channel, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;send&lt;/code&gt; will suspend the producer until there’s space for the new element in the channel whereas &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;offer&lt;/code&gt; won’t add the element to the channel and will return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt; immediately.&lt;/p&gt;

&lt;h4 id=&quot;awaitclose-under-the-hood&quot;&gt;awaitClose under the hood&lt;/h4&gt;

&lt;p&gt;Interestingly, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;awaitClose&lt;/code&gt; uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;suspendCancellableCoroutine&lt;/code&gt; under the hood. See my own comments in the following code snippet (following the &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/channels/Produce.kt#L49&quot;&gt;original implementation&lt;/a&gt;) to understand what’s happening:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ProducerScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;*&amp;gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;awaitClose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Unit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Suspend the coroutine with a cancellable continuation&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;suspendCancellableCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Suspend forever and resume the coroutine successfully only &lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// when the Flow/Channel is closed&lt;/span&gt;
      &lt;span class=&quot;nf&quot;&gt;invokeOnClose&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;resume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Always execute caller's clean up code&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;reusing-the-flow&quot;&gt;Reusing the Flow&lt;/h4&gt;

&lt;p&gt;Flows are cold and lazy unless specified otherwise with intermediate operators such as &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;conflate&lt;/code&gt;&lt;/a&gt;. This means that the builder block will be executed each time a terminal operator is called on the flow. This might not be a huge problem in our case as adding new location listeners is cheap, however, it might make a difference in other implementations.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;FusedLocationProviderClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callbackFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;shareIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Make the flow follow the applicationScope&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;applicationScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Emit the last emitted element to new collectors&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;replay&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Keep the producer active while there are active subscribers&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;started&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SharingStarted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;WhileSubscribed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To learn more about best practices for adding an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;applicationScope&lt;/code&gt; to your app, check out this &lt;a href=&quot;https://manuelvivo.dev/coroutines-cancellation-exceptions-4&quot;&gt;article&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Consider creating coroutine adapters to make your APIs or existing APIs concise, readable and Kotlin idiomatic. First check if the adapter is already available and if not, create your own using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;suspendCancellableCoroutine&lt;/code&gt; for one-shot calls and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt; for streaming data.&lt;/p&gt;

&lt;p&gt;To get hands-on this topic, check out the &lt;a href=&quot;https://codelabs.developers.google.com/codelabs/building-kotlin-extensions-library&quot;&gt;&lt;em&gt;Building a Kotlin extensions library&lt;/em&gt; codelab&lt;/a&gt;.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Manuel Vivo</name>
        
        
      </author>

      

      
        <category term="coroutines" />
      

      
        <summary type="html">Learn how to create your own coroutine adapters and see how they work under the hood</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Going with the Flow</title>
      <link href="https://manuelvivo.dev/going-with-the-flow" rel="alternate" type="text/html" title="Going with the Flow" />
      <published>2020-11-24T00:00:00+00:00</published>
      <updated>2020-11-24T00:00:00+00:00</updated>
      <id>https://manuelvivo.dev/going-with-the-flow</id>
      <content type="html" xml:base="https://manuelvivo.dev/going-with-the-flow">&lt;p&gt;Introduction to coroutines Flow&lt;/p&gt;

&lt;h2 id=&quot;description&quot;&gt;Description&lt;/h2&gt;

&lt;p&gt;Suspend functions in Coroutines are meant for one-shot calls that could return a result. But, how can you create a stream of data to return multiple results over time? In this video of Kotlin Vocabulary, Manuel will give us the benefits of Kotlin Flow, and much more!&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/emk9_tVVLcc&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h3 id=&quot;resources&quot;&gt;Resources&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://goo.gle/35PMGrh&quot;&gt;The ABC of Coroutines episode&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://d.android.com/kotlin/flow&quot;&gt;Flow documentation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://goo.gle/2wHr94N&quot;&gt;Watch more Kotlin Vocabulary&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://goo.gle/AndroidDevs&quot;&gt;Subscribe to Android Developers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Manuel Vivo</name>
        
        
      </author>

      

      
        <category term="talks" />
      
        <category term="coroutines" />
      

      
        <summary type="html">Introduction to coroutines Flow</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Android Coroutines - How to manage async tasks in Kotlin</title>
      <link href="https://manuelvivo.dev/coroutines-in-2020" rel="alternate" type="text/html" title="Android Coroutines - How to manage async tasks in Kotlin" />
      <published>2020-07-13T00:00:00+00:00</published>
      <updated>2020-07-13T00:00:00+00:00</updated>
      <id>https://manuelvivo.dev/coroutines-in-2020</id>
      <content type="html" xml:base="https://manuelvivo.dev/coroutines-in-2020">&lt;p&gt;State of coroutines on Android in 2020&lt;/p&gt;

&lt;h2 id=&quot;description&quot;&gt;Description&lt;/h2&gt;

&lt;p&gt;Take a good look at the current state of coroutines support in Android libraries and tools, explore some interesting and not-so-obvious edge cases when dealing with Kotlin code that includes coroutines and interop with Java, and briefly look at some new developments in Kotlin coroutines, namely StateFlow and its comparison with LiveData, and SharedFlow.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/6manrgTPzyA&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h3 id=&quot;resources&quot;&gt;Resources&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://goo.gle/coroutines-posts&quot;&gt;Coroutines blog posts&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://goo.gle/2R3DS9k&quot;&gt;Coroutines codelab&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://goo.gle/2R1ojz6&quot;&gt;Advanced coroutines codelab&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://goo.gle/3bMiUn8&quot;&gt;Testing coroutines talk&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://goo.gle/39wgxU8&quot;&gt;Cancellation and exceptions in coroutines&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://goo.gle/30FDT8S&quot;&gt;Check out the 11 Weeks of Android website&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://goo.gle/AndroidDevs&quot;&gt;Subscribe to Android Developers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Manuel Vivo</name>
        
        
      </author>

      

      
        <category term="talks" />
      
        <category term="coroutines" />
      

      
        <summary type="html">State of coroutines on Android in 2020</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Coroutines &amp;amp; Patterns for work that shouldn’t be cancelled</title>
      <link href="https://manuelvivo.dev/coroutines-cancellation-exceptions-4" rel="alternate" type="text/html" title="Coroutines &amp; Patterns for work that shouldn’t be cancelled" />
      <published>2020-04-07T00:00:00+00:00</published>
      <updated>2020-04-07T00:00:00+00:00</updated>
      <id>https://manuelvivo.dev/coroutines-cancellation-exceptions-4</id>
      <content type="html" xml:base="https://manuelvivo.dev/coroutines-cancellation-exceptions-4">&lt;p&gt;Best practices for work that needs to run beyond its current scope with an applicationScope!&lt;/p&gt;

&lt;p&gt;In &lt;a href=&quot;https://medium.com/androiddevelopers/cancellation-in-coroutines-aa6b90163629&quot;&gt;part 2 of the Cancellation and Exceptions in Coroutines series&lt;/a&gt;, we learnt the importance of cancelling work when it’s no longer needed. On Android, you can use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScopes&lt;/code&gt; provided by Jetpack: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;viewModelScope&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lifecycleScope&lt;/code&gt; that cancel any running work when their scope completes — that is when the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Activity/Fragment/Lifecycle&lt;/code&gt; completes. If you’re creating your own &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt;, make sure you tie it to a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Job&lt;/code&gt; and call cancel when needed.&lt;/p&gt;

&lt;p&gt;However, there are cases when you want an operation to complete even if the user navigated away from a screen. As such, you &lt;em&gt;don’t&lt;/em&gt; want the work to be cancelled (e.g. writing to a database or making a certain network request to your server).&lt;/p&gt;

&lt;p&gt;Keep reading for a pattern to achieve this!&lt;/p&gt;

&lt;h2 id=&quot;coroutines-or-workmanager&quot;&gt;Coroutines or WorkManager?&lt;/h2&gt;

&lt;p&gt;Coroutines will run as long as your application process is alive. If you need to run operations that should outlive the process (e.g. sending logs to your remote server), use &lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/workmanager&quot;&gt;WorkManager&lt;/a&gt; instead on Android. WorkManager is the library to use for critical operations that are expected to execute at some point in the future.&lt;/p&gt;

&lt;p&gt;Use coroutines for operations that are valid in the current process and can be cancelled if the user kills the app (e.g. making a network request you want to cache). What’s the pattern to trigger these operations?&lt;/p&gt;

&lt;h2 id=&quot;coroutines-best-practices&quot;&gt;Coroutines best practices&lt;/h2&gt;

&lt;p&gt;Since this pattern builds upon other coroutine best practices; let’s recap them:&lt;/p&gt;

&lt;h3 id=&quot;1-inject-dispatchers-into-classes&quot;&gt;1. Inject Dispatchers into classes&lt;/h3&gt;

&lt;p&gt;Don’t hardcode them when creating new coroutines or calling &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;withContext&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;✅ Benefits: ease of testing as you can easily replace them for both unit and instrumentation tests.&lt;/p&gt;

&lt;h3 id=&quot;2-the-viewmodelpresenter-layer-should-create-coroutines&quot;&gt;2. The ViewModel/Presenter layer should create coroutines&lt;/h3&gt;

&lt;p&gt;If it’s a UI-only operation, then the UI layer can do it. If you think this is not possible in your project, it’s likely you’re not following best practice #1 (i.e. it’s more difficult to test VMs that don’t inject &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dispatchers&lt;/code&gt;; in that case exposing suspend functions makes it doable).&lt;/p&gt;

&lt;p&gt;✅ Benefits: The UI layer should be dumb and not directly trigger any business logic. Instead, defer that responsibility to the ViewModel/Presenter layer. Testing the UI layer requires instrumentation tests in Android which need an emulator to run.&lt;/p&gt;

&lt;h3 id=&quot;3-the-layers-below-the-viewmodelpresenter-layer-should-expose-suspend-functions-and-flows&quot;&gt;3. The layers below the ViewModel/Presenter layer should expose suspend functions and Flows&lt;/h3&gt;

&lt;p&gt;If you need to create coroutines, use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;coroutineScope&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;supervisorScope&lt;/code&gt;&lt;/a&gt;. If you need them to follow a different scope, this is what this article is about! Keep reading!&lt;/p&gt;

&lt;p&gt;✅ Benefits: The caller (generally the ViewModel layer) can control the execution and lifecycle of the work happening in those layers, being able to cancel when needed.&lt;/p&gt;

&lt;h2 id=&quot;operations-that-shouldnt-be-cancelled-in-coroutines&quot;&gt;Operations that shouldn’t be cancelled in Coroutines&lt;/h2&gt;

&lt;p&gt;Imagine we have a ViewModel and a Repository in our app with the following logic:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;repo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Repository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;callRepo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;viewModelScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;repo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;doWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Repository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;ioDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;withContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ioDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nf&quot;&gt;doSomeOtherWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;nf&quot;&gt;veryImportantOperation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// This shouldn’t be cancelled&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We don’t want &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;veryImportantOperation()&lt;/code&gt; to be controlled by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;viewModelScope&lt;/code&gt; as it could be cancelled at any point. We want that operation to outlive &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;viewModelScope&lt;/code&gt;. How can we achieve that?&lt;/p&gt;

&lt;p&gt;To do this, &lt;strong&gt;create your own scope in the Application class and call those operations in coroutines started by it&lt;/strong&gt;. That scope should be injected in the classes that need it.&lt;/p&gt;

&lt;p&gt;The benefits of creating your own &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt; vs other solutions we’ll see later (like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GlobalScope&lt;/code&gt;) is that you can configure it as you wish. Do you need a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineExceptionHandler&lt;/code&gt;&lt;/a&gt;? Do you have your own thread pool you use as a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;? Place all that common configuration there in its &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineContext&lt;/code&gt;!&lt;/p&gt;

&lt;p&gt;You can call it &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;applicationScope&lt;/code&gt; and it must contain a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SupervisorJob()&lt;/code&gt; so that failures in coroutines don’t propagate in the hierarchy (as seen in &lt;a href=&quot;https://manuelvivo.dev/coroutines-cancellation-exceptions-3&quot;&gt;part 3 of the series&lt;/a&gt;):&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyApplication&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Application&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// No need to cancel this scope as it'll be torn down with the process&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;applicationScope&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SupervisorJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We don’t need to cancel this scope since we want it to remain active as long as the application process is alive, so we don’t hold a reference to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SupervisorJob&lt;/code&gt;. We can use this scope to run coroutines that need a longer lifetime than the calling scope might offer in our app.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For operations that shouldn’t be cancelled, call them from a coroutine created by an application CoroutineScope&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Whenever you create a new Repository instance, pass in the applicationScope we created above&lt;/strong&gt;. For tests, check out the &lt;em&gt;Testing&lt;/em&gt; section below.&lt;/p&gt;

&lt;h3 id=&quot;which-coroutine-builder-to-use&quot;&gt;Which coroutine builder to use?&lt;/h3&gt;

&lt;p&gt;Depending on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;veryImportantOperation&lt;/code&gt;’s behavior, you’d need to start a new coroutine using either launch or async:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;If it needs to return a result, use &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;async&lt;/code&gt;&lt;/strong&gt; and call &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;await&lt;/code&gt;&lt;/strong&gt; to wait for it to finish.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If not, use &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;launch&lt;/code&gt;&lt;/strong&gt; and wait for it to finish with &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;join&lt;/code&gt;&lt;/strong&gt;. Note that as explained in &lt;a href=&quot;https://manuelvivo.dev/coroutines-cancellation-exceptions-3&quot;&gt;part 3 of the series&lt;/a&gt;, you have to handle exceptions manually inside the launch block.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is how you’d trigger the coroutine using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;launch&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Repository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;ioDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineDispatcher&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;withContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ioDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nf&quot;&gt;doSomeOtherWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// if this can throw an exception, wrap inside try/catch&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// or rely on a CoroutineExceptionHandler installed&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// in the externalScope's CoroutineScope&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;veryImportantOperation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;or using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;async&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Repository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;ioDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineDispatcher&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Any&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Use a specific type in Result&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;withContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ioDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nf&quot;&gt;doSomeOtherWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Exceptions are exposed when calling await, they will be&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// propagated in the coroutine that called doWork. Watch&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// out! They will be ignored if the calling context cancels.&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;veryImportantOperation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In any case, the ViewModel code doesn’t change and with the above, even if the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;viewModelScope&lt;/code&gt; gets destroyed, the work using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;externalScope&lt;/code&gt; will keep running. Furthermore, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;doWork()&lt;/code&gt; won’t return until &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;veryImportantOperation()&lt;/code&gt; completes as with any other suspend call.&lt;/p&gt;

&lt;h3 id=&quot;what-about-something-simpler&quot;&gt;What about something simpler?&lt;/h3&gt;

&lt;p&gt;Another pattern that could serve some use cases (and it’s probably the first solution anyone would come up with) is wrapping &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;veryImportantOperation&lt;/code&gt; in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;externalScope&lt;/code&gt;’s context using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;withContext&lt;/code&gt; as follows:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Repository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;ioDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineDispatcher&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;withContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ioDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nf&quot;&gt;doSomeOtherWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;nf&quot;&gt;withContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutineContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;veryImportantOperation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;However, this approach has some caveats that you should be aware of:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;If the coroutine that calls &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;doWork&lt;/code&gt; is cancelled while &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;veryImportantOperation&lt;/code&gt; is getting executed, the coroutine will keep executing until the next cancellation point, not after &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;veryImportantOperation&lt;/code&gt; finishes executing.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineExceptionHandler&lt;/code&gt;s don’t work as you’d expect when the context is used in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;withContext&lt;/code&gt; since the exception will be re-thrown.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;testing&quot;&gt;Testing&lt;/h2&gt;

&lt;p&gt;As we’ll need to inject both &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dispatchers&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt;s, what should you inject in those cases?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/images/2020-04-07-coroutines-cancellation-exceptions-4.png&quot; alt=&quot;img&quot; /&gt;
&lt;small&gt;What to inject in testing&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;🔖 Legend: &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-dispatcher/index.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TestCoroutineDispatcher&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://github.com/android/plaid/blob/master/test_shared/src/main/java/io/plaidapp/test/shared/MainCoroutineRule.kt&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MainCoroutineRule&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scope/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TestCoroutineScope&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://github.com/google/iosched/blob/adssched/mobile/src/androidTest/java/com/google/samples/apps/iosched/tests/di/TestCoroutinesModule.kt#L36&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AsyncTask.THREAD_POOL_EXECUTOR.asCoroutineDispatcher()&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;alternatives&quot;&gt;Alternatives&lt;/h2&gt;

&lt;p&gt;There are other ways to implement this behavior with Coroutines. However, those solutions cannot be applied systematically in all use cases. Let’s see some alternatives and why/when you should/shouldn’t use them.&lt;/p&gt;

&lt;h3 id=&quot;-globalscope&quot;&gt;❌ GlobalScope&lt;/h3&gt;

&lt;p&gt;There are multiple reasons why you shouldn’t use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GlobalScope&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Promotes hard-coding values&lt;/strong&gt;. It might be tempting to hardcode &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dispatchers&lt;/code&gt; if you use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GlobalScope&lt;/code&gt; straight-away. That’s a bad practice!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;It makes testing very hard&lt;/strong&gt;. As your code is going to be executed in an uncontrolled scope, you won’t be able to manage execution of work started by it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;You can’t have a common CoroutineContext for all coroutines&lt;/strong&gt; built into the scope as we did with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;applicationScope&lt;/code&gt;. Instead, you’d have to pass a common &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineContext&lt;/code&gt; to all coroutines started by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GlobalScope&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Recommendation: Don’t use it directly.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;-processlifecycleowner-scope-in-android&quot;&gt;❌ ProcessLifecycleOwner scope in Android&lt;/h3&gt;

&lt;p&gt;In Android, there’s an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;applicationScope&lt;/code&gt; available in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;androidx.lifecycle:lifecycle-process&lt;/code&gt; library, accessed with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ProcessLifecycleOwner.get().lifecycleScope&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this case, you’d inject a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LifecycleOwner&lt;/code&gt; instead of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt; as we did before. In production, you’d pass in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ProcessLifecycleOwner.get()&lt;/code&gt; and in unit tests, you can create a fake &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LifecycleOwner&lt;/code&gt; using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LifecycleRegistry&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Notice that the default &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineContext&lt;/code&gt; of this scope uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dispatchers.Main.immediate&lt;/code&gt; which might not be desirable for background work. As with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GlobalScope&lt;/code&gt;, you’d have to pass a common &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineContext&lt;/code&gt; to all coroutines started by it.&lt;/p&gt;

&lt;p&gt;Because of all the above, this alternative requires more work than just creating a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt; in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Application&lt;/code&gt; class. Also, I don’t personally like having classes related to the Android lifecycle in layers below the ViewModel/Presenter as these layers should be platform agnostic.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Recommendation: Don’t use it directly.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;️-disclaimer&quot;&gt;⚠️ Disclaimer&lt;/h3&gt;

&lt;p&gt;If it turns out that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoroutineContext&lt;/code&gt; of your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;applicationScope&lt;/code&gt; matches the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GlobalScope&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ProcessLifecycleOwner.get().lifecycleScope&lt;/code&gt; one, you can directly assign them as follows:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyApplication&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Application&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;applicationScope&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GlobalScope&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You still get all the &lt;em&gt;benefits&lt;/em&gt; mentioned above and you can easily change it if needed in the future.&lt;/p&gt;

&lt;h3 id=&quot;--using-noncancellable&quot;&gt;❌ ✅ Using NonCancellable&lt;/h3&gt;

&lt;p&gt;As seen in &lt;a href=&quot;https://medium.com/androiddevelopers/cancellation-in-coroutines-aa6b90163629&quot;&gt;part 2 of the series&lt;/a&gt;, you can use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;withContext(NonCancellable)&lt;/code&gt; to be able to call suspend functions in a cancelled coroutine. We suggested using it to perform cleanup code that can suspend. However, you shouldn’t abuse it.&lt;/p&gt;

&lt;p&gt;Doing this is very risky as you lose control of the execution of the coroutine. It’s true that it produces more concise and easier to read code but the problems this can cause in the future are unpredictable.&lt;/p&gt;

&lt;p&gt;Example of its usage:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Repository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;ioDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineDispatcher&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;withContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ioDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nf&quot;&gt;doSomeOtherWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;nf&quot;&gt;withContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;NonCancellable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;veryImportantOperation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As very tempting as it can be to do, you might not always know what’s behind &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;veryImportantOperation()&lt;/code&gt;: maybe it’s an external library, maybe the implementation is behind an interface,… What problems can happen?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;You won’t be able to stop those operations in tests.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;An endless loop that uses delay won’t be able to cancel anymore.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Collecting a Flow within it makes the Flow non-cancellable from the outside.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;…&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These problems can lead to subtle and very hard to debug bugs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Recommendation: use it ONLY for suspending cleanup code.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Whenever you need some work to run beyond its current scope, we recommend creating a custom scope in your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Application&lt;/code&gt; class and running coroutines within it. Avoid using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GlobalScope&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ProcessLifecycleOwner&lt;/code&gt; scope and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NonCancellable&lt;/code&gt; for this type of work.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Manuel Vivo</name>
        
        
      </author>

      

      
        <category term="coroutines" />
      

      
        <summary type="html">Best practices for work that needs to run beyond its current scope with an applicationScope!</summary>
      

      
      
    </entry>
  
</feed>
